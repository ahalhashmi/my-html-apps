<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Portrait String Art (Nails + Thread) – iPhone HTML App</title>
  <style>
    :root { --bg:#0b0c10; --panel:#111318; --text:#e9eef7; --muted:#aab3c5; --line:#2a2f3a; --btn:#1f6feb; }
    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    body{
      margin:0; background:linear-gradient(180deg,#090a0e,#0b0c10);
      color:var(--text); font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial;
      padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom) 12px;
    }
    h1{ font-size:18px; margin:10px 0 6px; }
    .wrap{ max-width: 980px; margin:0 auto; }
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    @media (min-width: 900px){
      .grid{ grid-template-columns: 380px 1fr; align-items:start; }
    }
    .card{
      background:rgba(17,19,24,.92);
      border:1px solid rgba(42,47,58,.9);
      border-radius:16px;
      padding:12px;
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
    }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
    input[type="range"]{ width:100%; }
    input[type="file"]{ width:100%; }
    select{
      width:100%;
      border-radius:14px; padding:12px 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color: var(--text);
      font-weight:600;
    }
    .btn{
      appearance:none; border:1px solid rgba(255,255,255,.10);
      background: rgba(31,111,235,.95);
      color:white; padding:12px 14px; border-radius:14px;
      font-weight:600; width:100%;
    }
    .btn:disabled{ opacity:.5; }
    .btn2{
      appearance:none; border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color:var(--text); padding:12px 14px; border-radius:14px;
      font-weight:600; width:100%;
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .small{ font-size:12px; color:var(--muted); line-height:1.35; }
    .hr{ height:1px; background: rgba(42,47,58,.9); margin:12px 0; }
    .canvasWrap{
      display:grid; gap:12px;
      grid-template-columns: 1fr;
    }
    @media (min-width: 900px){
      .canvasWrap{ grid-template-columns: 1fr 1fr; }
    }
    canvas{
      width:100%; aspect-ratio:1/1;
      border-radius:18px; background:#fff;
      border:1px solid rgba(42,47,58,.9);
      touch-action: none;
    }
    .stat{
      display:flex; justify-content:space-between; gap:8px;
      font-size:12px; color:var(--muted);
      padding:8px 10px; border-radius:12px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.08);
      margin-top:10px;
    }
    textarea{
      width:100%; min-height:180px; resize:vertical;
      border-radius:14px; padding:10px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color: var(--text);
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      font-size:12px; color:var(--muted);
      margin:6px 0 0;
    }
    .hint{ font-size:12px; color:var(--muted); margin-top:8px; }
    .row2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Portrait String Art Generator (Digital Preview + Nail Sequence)</h1>
  <div class="small">
    Upload a photo → center-crop into a circle → adjust nails + filters → preview “black thread on white” →
    Generate a step-by-step nail sequence. Nail <b>0</b> starts at <b>12 o’clock</b> and counts clockwise.
  </div>

  <div class="grid" style="margin-top:12px;">
    <!-- Controls -->
    <div class="card">
      <label>1) Upload photo</label>
      <input id="file" type="file" accept="image/*" />

      <div class="pill">Tip: Drag on the <b>Crop</b> canvas to reposition. Use Zoom slider for sizing.</div>

      <label>Zoom (crop)</label>
      <input id="zoom" type="range" min="1" max="3" step="0.01" value="1.3" />

      <div class="hr"></div>

      <label>Preset</label>
      <select id="preset">
        <option value="default">Default (Balanced)</option>
        <option value="fast">Fast Preview</option>
        <option value="detail">More Detail</option>
        <option value="high">High Complexity</option>
      </select>

      <div class="row" style="margin-top:10px;">
        <button id="resetBtn" class="btn2" disabled>Reset to Default</button>
      </div>

      <div class="hr"></div>

      <label>2) Nails count (min 4)</label>
      <input id="nails" type="range" min="4" max="360" step="1" value="180" />
      <div class="stat"><span>Nails</span><span id="nailsVal">180</span></div>

      <label>Lines (thread segments)</label>
      <input id="lines" type="range" min="50" max="8000" step="10" value="1400" />
      <div class="stat"><span>Lines</span><span id="linesVal">1400</span></div>

      <label>Thread strength (darkness per line)</label>
      <input id="alpha" type="range" min="0.01" max="0.25" step="0.005" value="0.07" />
      <div class="stat"><span>Alpha</span><span id="alphaVal">0.070</span></div>

      <label>Line thickness (preview + final render)</label>
      <input id="thick" type="range" min="0.5" max="3.0" step="0.1" value="1.2" />
      <div class="stat"><span>Thickness</span><span id="thickVal">1.2</span></div>

      <div class="hr"></div>

      <label>3) Image filtering</label>
      <div class="row2">
        <div>
          <label style="margin-top:0;">Brightness</label>
          <input id="bright" type="range" min="-60" max="60" step="1" value="0" />
          <div class="stat"><span>Value</span><span id="brightVal">0</span></div>
        </div>
        <div>
          <label style="margin-top:0;">Contrast</label>
          <input id="contrast" type="range" min="-60" max="60" step="1" value="10" />
          <div class="stat"><span>Value</span><span id="contrastVal">10</span></div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row" style="gap:10px;">
        <button id="previewBtn" class="btn2" disabled>Update Preview</button>
        <button id="generateBtn" class="btn" disabled>Generate Sequence</button>
      </div>

      <div class="row" style="gap:10px; margin-top:10px;">
        <button id="stopBtn" class="btn2" disabled>Stop</button>
        <button id="downloadBtn" class="btn2" disabled>Download .txt</button>
      </div>

      <div class="hint">
        Presets just set sliders quickly. You can still fine-tune after picking a preset.
      </div>

      <div class="stat" style="margin-top:12px;">
        <span>Status</span><span id="status">Load a photo</span>
      </div>
      <div class="stat">
        <span>Progress</span><span id="progress">0%</span>
      </div>
    </div>

    <!-- Canvases + Output -->
    <div class="card">
      <div class="canvasWrap">
        <div>
          <label style="margin-top:0;">Crop (circle)</label>
          <canvas id="crop" width="900" height="900"></canvas>
          <div class="small">Drag to reposition inside the circle. Outside the circle is ignored.</div>
        </div>
        <div>
          <label style="margin-top:0;">String Art Preview (black thread on white)</label>
          <canvas id="preview" width="900" height="900"></canvas>
          <div class="small">Preview of the result using your settings.</div>
        </div>
      </div>

      <div class="hr"></div>

      <label>Generated nail sequence</label>
      <textarea id="output" class="mono" placeholder="After generating, you’ll see steps like: 0 → 58 → 12 → ..."></textarea>
      <div class="small">
        Nail indices are <b>0..N-1</b>, where <b>0</b> is at 12 o’clock and counting is clockwise.
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ====== Elements
  const fileEl = document.getElementById('file');
  const cropCanvas = document.getElementById('crop');
  const prevCanvas = document.getElementById('preview');
  const cropCtx = cropCanvas.getContext('2d', { willReadFrequently:true });
  const prevCtx = prevCanvas.getContext('2d', { willReadFrequently:true });

  const zoomEl = document.getElementById('zoom');
  const presetEl = document.getElementById('preset');
  const resetBtn = document.getElementById('resetBtn');

  const nailsEl = document.getElementById('nails');
  const linesEl = document.getElementById('lines');
  const alphaEl = document.getElementById('alpha');
  const thickEl = document.getElementById('thick');
  const brightEl = document.getElementById('bright');
  const contrastEl = document.getElementById('contrast');

  const nailsVal = document.getElementById('nailsVal');
  const linesVal = document.getElementById('linesVal');
  const alphaVal = document.getElementById('alphaVal');
  const thickVal = document.getElementById('thickVal');
  const brightVal = document.getElementById('brightVal');
  const contrastVal = document.getElementById('contrastVal');

  const previewBtn = document.getElementById('previewBtn');
  const generateBtn = document.getElementById('generateBtn');
  const stopBtn = document.getElementById('stopBtn');
  const downloadBtn = document.getElementById('downloadBtn');

  const statusEl = document.getElementById('status');
  const progressEl = document.getElementById('progress');
  const outputEl = document.getElementById('output');

  // ====== Defaults + Presets
  const DEFAULTS = Object.freeze({
    zoom: 1.3,
    nails: 180,
    lines: 1400,
    alpha: 0.07,
    thick: 1.2,
    bright: 0,
    contrast: 10
  });

  const PRESETS = {
    default: { ...DEFAULTS },
    fast:    { zoom: 1.25, nails: 120, lines: 600,  alpha: 0.08, thick: 1.2, bright: 0,  contrast: 8  },
    detail:  { zoom: 1.35, nails: 220, lines: 2500, alpha: 0.06, thick: 1.1, bright: 0,  contrast: 14 },
    high:    { zoom: 1.40, nails: 300, lines: 5000, alpha: 0.05, thick: 1.0, bright: -2, contrast: 18 }
  };

  // ====== State
  let img = null;
  let imgReady = false;

  // crop control
  let offsetX = 0, offsetY = 0;
  let isDragging = false;
  let lastX = 0, lastY = 0;

  let stopFlag = false;
  let lastGeneratedSequence = null;

  // internal working size for math
  const WORK = 260;
  const workCanvas = document.createElement('canvas');
  workCanvas.width = WORK;
  workCanvas.height = WORK;
  const workCtx = workCanvas.getContext('2d', { willReadFrequently:true });

  // ====== UI helpers
  function setStatus(s){ statusEl.textContent = s; }
  function setProgress(p){ progressEl.textContent = `${p.toFixed(0)}%`; }
  function setEnabled(enabled){
    previewBtn.disabled = !enabled;
    generateBtn.disabled = !enabled;
    resetBtn.disabled = !enabled;
    presetEl.disabled = !enabled;
  }
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  function updateLabels(){
    nailsVal.textContent = nailsEl.value;
    linesVal.textContent = linesEl.value;
    alphaVal.textContent = Number(alphaEl.value).toFixed(3);
    thickVal.textContent = Number(thickEl.value).toFixed(1);
    brightVal.textContent = brightEl.value;
    contrastVal.textContent = contrastEl.value;
  }

  function applySettings(s){
    // enforce slider limits (esp lines up to 8000)
    zoomEl.value = String(clamp(s.zoom, 1, 3));
    nailsEl.value = String(clamp(s.nails, 4, 360));
    linesEl.value = String(clamp(s.lines, 50, 8000));
    alphaEl.value = String(clamp(s.alpha, 0.01, 0.25));
    thickEl.value = String(clamp(s.thick, 0.5, 3.0));
    brightEl.value = String(clamp(s.bright, -60, 60));
    contrastEl.value = String(clamp(s.contrast, -60, 60));
    updateLabels();
    drawCrop();
  }

  [nailsEl, linesEl, alphaEl, thickEl, brightEl, contrastEl].forEach(el=>{
    el.addEventListener('input', updateLabels);
  });
  updateLabels();

  // ====== Geometry: nails evenly spaced on a circle.
  // Nail 0 at 12 o'clock, then clockwise.
  function computePins(n, radius, cx, cy){
    const pins = new Array(n);
    for(let i=0;i<n;i++){
      const t = (i / n) * Math.PI * 2;
      const ang = -Math.PI/2 + t;
      pins[i] = { x: cx + radius*Math.cos(ang), y: cy + radius*Math.sin(ang) };
    }
    return pins;
  }

  // ====== Crop rendering
  function drawCrop(){
    const w = cropCanvas.width, h = cropCanvas.height;
    cropCtx.clearRect(0,0,w,h);
    cropCtx.fillStyle = '#fff';
    cropCtx.fillRect(0,0,w,h);

    const cx = w/2, cy = h/2;
    const R = w*0.43;

    if(!img){
      cropCtx.save();
      cropCtx.strokeStyle = '#ccc';
      cropCtx.lineWidth = 4;
      cropCtx.beginPath();
      cropCtx.arc(cx,cy,R,0,Math.PI*2);
      cropCtx.stroke();
      cropCtx.restore();

      cropCtx.fillStyle = '#555';
      cropCtx.font = '28px system-ui, -apple-system';
      cropCtx.textAlign = 'center';
      cropCtx.fillText('Upload a photo', cx, cy);
      return;
    }

    cropCtx.save();
    cropCtx.beginPath();
    cropCtx.arc(cx,cy,R,0,Math.PI*2);
    cropCtx.clip();

    const z = Number(zoomEl.value);
    const baseScale = Math.max((2*R)/img.width, (2*R)/img.height);
    const scale = baseScale * z;

    const dw = img.width * scale;
    const dh = img.height * scale;

    const dx = cx - dw/2 + offsetX;
    const dy = cy - dh/2 + offsetY;

    cropCtx.drawImage(img, dx, dy, dw, dh);
    cropCtx.restore();

    cropCtx.save();
    cropCtx.strokeStyle = 'rgba(0,0,0,.2)';
    cropCtx.lineWidth = 4;
    cropCtx.beginPath();
    cropCtx.arc(cx,cy,R,0,Math.PI*2);
    cropCtx.stroke();
    cropCtx.restore();
  }

  function getPointerPos(ev, canvas){
    const rect = canvas.getBoundingClientRect();
    const touch = ev.touches ? ev.touches[0] : ev;
    return {
      x: (touch.clientX - rect.left) * (canvas.width / rect.width),
      y: (touch.clientY - rect.top) * (canvas.height / rect.height),
    };
  }

  cropCanvas.addEventListener('pointerdown', (ev)=>{
    if(!img) return;
    isDragging = true;
    cropCanvas.setPointerCapture(ev.pointerId);
    const p = getPointerPos(ev, cropCanvas);
    lastX = p.x; lastY = p.y;
  });
  cropCanvas.addEventListener('pointermove', (ev)=>{
    if(!img || !isDragging) return;
    const p = getPointerPos(ev, cropCanvas);
    offsetX += (p.x - lastX);
    offsetY += (p.y - lastY);
    lastX = p.x; lastY = p.y;
    drawCrop();
  });
  cropCanvas.addEventListener('pointerup', ()=>{ isDragging = false; });
  cropCanvas.addEventListener('pointercancel', ()=>{ isDragging = false; });

  zoomEl.addEventListener('input', drawCrop);

  // ====== Build target darkness map (WORK)
  function buildTargetDarkness(){
    const w = WORK, h = WORK;
    workCtx.clearRect(0,0,w,h);
    workCtx.fillStyle = '#fff';
    workCtx.fillRect(0,0,w,h);

    workCtx.drawImage(cropCanvas, 0, 0, w, h);

    const imgData = workCtx.getImageData(0,0,w,h);
    const d = imgData.data;

    const b = Number(brightEl.value);
    const c = Number(contrastEl.value);
    const cf = (259 * (c + 255)) / (255 * (259 - c));

    const out = new Float32Array(w*h);

    const cx = w/2, cy = h/2;
    const R = w*0.43;
    const R2 = R*R;

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const idx = (y*w + x);
        const i4 = idx*4;

        const dx = x - cx, dy = y - cy;
        if(dx*dx + dy*dy > R2){
          out[idx] = 0;
          continue;
        }

        let r = d[i4], g = d[i4+1], bl = d[i4+2];

        r = cf*(r - 128) + 128 + b;
        g = cf*(g - 128) + 128 + b;
        bl = cf*(bl - 128) + 128 + b;

        r = r<0?0:r>255?255:r;
        g = g<0?0:g>255?255:g;
        bl = bl<0?0:bl>255?255:bl;

        const gray = 0.2126*r + 0.7152*g + 0.0722*bl;
        out[idx] = (255 - gray) / 255;
      }
    }
    return out;
  }

  // ====== Line scoring + apply
  function lineScore(p0, p1, target, accDark, alpha, w, h){
    const dx = p1.x - p0.x, dy = p1.y - p0.y;
    const dist = Math.hypot(dx, dy);
    const steps = Math.max(8, Math.floor(dist));
    const sx = dx / steps, sy = dy / steps;

    let x = p0.x, y = p0.y;
    let score = 0;

    for(let i=0;i<=steps;i++){
      const xi = x|0, yi = y|0;
      if(xi>=0 && xi<w && yi>=0 && yi<h){
        const idx = yi*w + xi;
        const t = target[idx];
        const cur = accDark[idx];
        const need = t - cur;
        const add = alpha * (1 - cur);
        if(need > 0) score += need * add;
        else score += need * add * 0.35;
      }
      x += sx; y += sy;
    }
    return score;
  }

  function applyLineToDarkness(p0, p1, accDark, alpha, w, h){
    const dx = p1.x - p0.x, dy = p1.y - p0.y;
    const dist = Math.hypot(dx, dy);
    const steps = Math.max(8, Math.floor(dist));
    const sx = dx / steps, sy = dy / steps;

    let x = p0.x, y = p0.y;
    for(let i=0;i<=steps;i++){
      const xi = x|0, yi = y|0;
      if(xi>=0 && xi<w && yi>=0 && yi<h){
        const idx = yi*w + xi;
        const cur = accDark[idx];
        accDark[idx] = 1 - (1 - cur) * (1 - alpha);
      }
      x += sx; y += sy;
    }
  }

  // ====== Render
  function renderAccToPreview(accDark){
    const w = prevCanvas.width, h = prevCanvas.height;
    prevCtx.clearRect(0,0,w,h);
    prevCtx.fillStyle = '#fff';
    prevCtx.fillRect(0,0,w,h);

    const scale = w / WORK;

    for(let y=0;y<WORK;y++){
      for(let x=0;x<WORK;x++){
        const d = accDark[y*WORK + x];
        const g = Math.round(255 * (1 - d));
        prevCtx.fillStyle = `rgb(${g},${g},${g})`;
        prevCtx.fillRect(x*scale, y*scale, scale+0.2, scale+0.2);
      }
    }

    // pins (subtle)
    prevCtx.save();
    prevCtx.globalAlpha = 0.35;
    prevCtx.fillStyle = 'rgba(0,0,0,.6)';
    const n = Number(nailsEl.value);
    const pins = computePins(n, w*0.43, w/2, h/2);
    for(const p of pins){
      prevCtx.beginPath();
      prevCtx.arc(p.x, p.y, 2.1, 0, Math.PI*2);
      prevCtx.fill();
    }
    prevCtx.restore();
  }

  function renderSequenceAsLines(sequence){
    const w = prevCanvas.width, h = prevCanvas.height;
    prevCtx.clearRect(0,0,w,h);
    prevCtx.fillStyle = '#fff';
    prevCtx.fillRect(0,0,w,h);

    const n = Number(nailsEl.value);
    const pins = computePins(n, w*0.43, w/2, h/2);

    prevCtx.save();
    prevCtx.strokeStyle = '#000';
    prevCtx.globalAlpha = Number(alphaEl.value);
    prevCtx.lineWidth = Number(thickEl.value);
    prevCtx.lineCap = 'round';

    for(let i=0;i<sequence.length-1;i++){
      const a = pins[sequence[i]];
      const b = pins[sequence[i+1]];
      prevCtx.beginPath();
      prevCtx.moveTo(a.x, a.y);
      prevCtx.lineTo(b.x, b.y);
      prevCtx.stroke();
    }
    prevCtx.restore();

    prevCtx.save();
    prevCtx.globalAlpha = 0.35;
    prevCtx.fillStyle = 'rgba(0,0,0,.6)';
    for(const p of pins){
      prevCtx.beginPath();
      prevCtx.arc(p.x, p.y, 2.1, 0, Math.PI*2);
      prevCtx.fill();
    }
    prevCtx.restore();
  }

  // ====== Generator
  async function generateSequence({previewOnly=false}){
    stopFlag = false;
    stopBtn.disabled = false;
    downloadBtn.disabled = true;
    outputEl.value = '';
    lastGeneratedSequence = null;

    const n = Number(nailsEl.value);
    const totalLines = Number(linesEl.value);
    const alpha = Number(alphaEl.value);

    setStatus(previewOnly ? 'Building preview…' : 'Generating sequence…');
    setProgress(0);

    const pins = computePins(n, WORK*0.43, WORK/2, WORK/2);
    const target = buildTargetDarkness();
    const accDark = new Float32Array(WORK*WORK);

    let current = 0;
    const sequence = [current];
    let prev = -1;

    const sampleAll = n <= 220;
    const sampleStep = sampleAll ? 1 : Math.ceil(n / 220);

    const runLines = previewOnly ? Math.min(700, Math.max(150, Math.floor(totalLines * 0.25))) : totalLines;
    const chunk = previewOnly ? 14 : 10;

    for(let k=0;k<runLines;k++){
      if(stopFlag) break;

      let best = -1;
      let bestScore = -1e9;

      for(let j=0;j<n;j+=sampleStep){
        if(j === current) continue;
        if(j === prev) continue;
        const sc = lineScore(pins[current], pins[j], target, accDark, alpha, WORK, WORK);
        if(sc > bestScore){ bestScore = sc; best = j; }
      }

      if(best < 0){
        for(let j=0;j<n;j++){
          if(j===current || j===prev) continue;
          const sc = lineScore(pins[current], pins[j], target, accDark, alpha, WORK, WORK);
          if(sc > bestScore){ bestScore=sc; best=j; }
        }
      }

      if(best < 0) break;

      applyLineToDarkness(pins[current], pins[best], accDark, alpha, WORK, WORK);

      prev = current;
      current = best;
      sequence.push(current);

      if(k % chunk === 0){
        setProgress((k / runLines) * 100);

        if(previewOnly){
          renderAccToPreview(accDark);
        } else if(k % 200 === 0){
          renderSequenceAsLines(sequence);
        }

        await new Promise(r => setTimeout(r, 0));
      }
    }

    setProgress(100);
    if(stopFlag) setStatus('Stopped.');
    else setStatus(previewOnly ? 'Preview ready.' : 'Sequence ready.');

    if(previewOnly){
      renderSequenceAsLines(sequence);
      stopBtn.disabled = true;
      return;
    }

    lastGeneratedSequence = sequence;

    const header =
`Portrait String Art – Nail Sequence
-----------------------------------
Nails: ${n}
Lines: ${sequence.length - 1}
Nail 0: 12 o'clock (top), clockwise increasing
Preset: ${presetEl.value}

Sequence (nail indices):
`;

    const compact = sequence.join(' -> ');
    let steps = '\n\nStep-by-step:\n';
    for(let i=0;i<sequence.length-1;i++){
      steps += `${String(i+1).padStart(4,' ')}: ${sequence[i]} -> ${sequence[i+1]}\n`;
    }

    outputEl.value = header + compact + steps;
    downloadBtn.disabled = false;
    stopBtn.disabled = true;
  }

  // ====== Buttons
  previewBtn.addEventListener('click', async ()=>{
    if(!imgReady) return;
    try{
      drawCrop();
      await generateSequence({previewOnly:true});
    }catch(err){
      console.error(err);
      setStatus('Preview error (try fewer nails/lines).');
      stopBtn.disabled = true;
    }
  });

  generateBtn.addEventListener('click', async ()=>{
    if(!imgReady) return;
    try{
      drawCrop();
      await generateSequence({previewOnly:false});
    }catch(err){
      console.error(err);
      setStatus('Generation error (try fewer nails/lines).');
      stopBtn.disabled = true;
    }
  });

  stopBtn.addEventListener('click', ()=>{
    stopFlag = true;
    setStatus('Stopping…');
  });

  downloadBtn.addEventListener('click', ()=>{
    if(!lastGeneratedSequence) return;
    const n = Number(nailsEl.value);
    const lines = lastGeneratedSequence.length - 1;

    const text = outputEl.value || '';
    const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `string_art_sequence_${n}nails_${lines}lines.txt`;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{
      URL.revokeObjectURL(a.href);
      a.remove();
    }, 400);
  });

  // ====== Presets + Reset
  presetEl.addEventListener('change', ()=>{
    const key = presetEl.value;
    const s = PRESETS[key] || PRESETS.default;
    applySettings(s);
    setStatus(`Preset applied: ${key}. Update Preview.`);
  });

  resetBtn.addEventListener('click', ()=>{
    presetEl.value = 'default';
    applySettings(PRESETS.default);
    setStatus('Reset to Default. Update Preview.');
  });

  // ====== Image load
  fileEl.addEventListener('change', async (ev)=>{
    const f = ev.target.files && ev.target.files[0];
    if(!f) return;

    setStatus('Loading image…');
    setProgress(0);

    const url = URL.createObjectURL(f);
    const im = new Image();
    im.decoding = 'async';
    im.onload = ()=>{
      URL.revokeObjectURL(url);
      img = im;
      imgReady = true;

      offsetX = 0; offsetY = 0;
      presetEl.value = 'default';
      applySettings(PRESETS.default);

      prevCtx.clearRect(0,0,prevCanvas.width, prevCanvas.height);
      prevCtx.fillStyle = '#fff';
      prevCtx.fillRect(0,0,prevCanvas.width, prevCanvas.height);

      setStatus('Image loaded. Update Preview.');
      setProgress(0);
      setEnabled(true);
      stopBtn.disabled = true;
      downloadBtn.disabled = true;
    };
    im.onerror = ()=>{
      setStatus('Failed to load image.');
      imgReady = false;
      setEnabled(false);
    };
    im.src = url;
  });

  // ====== Initial draw
  applySettings(PRESETS.default);
  drawCrop();
  prevCtx.fillStyle = '#fff';
  prevCtx.fillRect(0,0,prevCanvas.width, prevCanvas.height);

  // ====== Quality of life
  outputEl.addEventListener('focus', ()=>{ outputEl.select(); });

})();
</script>
</body>
</html>