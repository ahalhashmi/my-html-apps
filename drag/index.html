<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Drag Simulator (Portrait)</title>
  <style>
    :root{
      --bg:#070A12;
      --panel:#0E1424;
      --panel2:#111A2F;
      --text:#EAF0FF;
      --muted:#98A6C7;
      --accent:#59D6FF;
      --good:#3CFF9A;
      --warn:#FFCE4A;
      --bad:#FF4C6A;
      --line:rgba(255,255,255,.10);
      --glass:rgba(255,255,255,.06);
      --shadow:0 14px 40px rgba(0,0,0,.45);
      --radius:16px;
      --radius2:12px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html,body{ height:100%; margin:0; background:radial-gradient(1200px 900px at 50% 10%, #0B1330 0%, var(--bg) 55%, #05060B 100%); color:var(--text); font-family:var(--sans); }
    body{ overflow:hidden; touch-action:none; }

    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      padding:10px;
      gap:10px;
      max-width:900px;
      margin:0 auto;
    }

    .topbar{
      display:flex;
      gap:10px;
      align-items:stretch;
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .cardHeader{
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background:rgba(255,255,255,.02);
    }
    .title{
      font-weight:800;
      letter-spacing:.3px;
      font-size:14px;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .badge{
      font-family:var(--mono);
      font-size:11px;
      color:rgba(255,255,255,.85);
      background:rgba(255,255,255,.06);
      border:1px solid var(--line);
      padding:2px 7px;
      border-radius:999px;
    }

    .btn{
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--text);
      border-radius:999px;
      padding:10px 12px;
      font-weight:700;
      font-size:13px;
      line-height:1;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      user-select:none;
      -webkit-user-select:none;
      cursor:pointer;
    }
    .btn:active{ transform:translateY(1px); }
    .btnPrimary{
      background:linear-gradient(180deg, rgba(89,214,255,.25), rgba(89,214,255,.10));
      border-color:rgba(89,214,255,.35);
    }
    .btnGood{
      background:linear-gradient(180deg, rgba(60,255,154,.25), rgba(60,255,154,.10));
      border-color:rgba(60,255,154,.35);
    }
    .btnBad{
      background:linear-gradient(180deg, rgba(255,76,106,.25), rgba(255,76,106,.10));
      border-color:rgba(255,76,106,.35);
    }

    .pillRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }
    .muted{ color:var(--muted); font-size:12px; }
    .mono{ font-family:var(--mono); }

    .main{
      flex:1;
      display:grid;
      grid-template-columns: 1fr;
      grid-template-rows: 1.25fr .95fr;
      gap:10px;
      min-height:0;
    }

    /* View (road + dash) */
    .view{
      position:relative;
      min-height:0;
    }
    canvas#road{
      width:100%;
      height:100%;
      display:block;
      background:linear-gradient(180deg, #04060C 0%, #070A12 55%, #02030A 100%);
    }

    .hud{
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      padding:10px;
      gap:10px;
      pointer-events:none;
    }

    .hudTop{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
      pointer-events:none;
    }

    .treeWrap{
      pointer-events:none;
      background:rgba(0,0,0,.28);
      border:1px solid var(--line);
      border-radius:14px;
      padding:8px 10px;
      display:flex;
      gap:10px;
      align-items:center;
      backdrop-filter: blur(8px);
    }
    .tree{
      display:grid;
      grid-template-columns: 18px 18px;
      gap:6px 10px;
      align-items:center;
    }
    .light{
      width:18px; height:18px;
      border-radius:999px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.20);
    }
    .light.on.pre{ background:rgba(100,180,255,.95); border-color:rgba(140,210,255,.7); box-shadow:0 0 18px rgba(100,180,255,.55); }
    .light.on.stage{ background:rgba(120,220,255,.95); border-color:rgba(160,240,255,.7); box-shadow:0 0 18px rgba(120,220,255,.55); }
    .light.on.amb{ background:rgba(255,206,74,.98); border-color:rgba(255,206,74,.75); box-shadow:0 0 18px rgba(255,206,74,.55); }
    .light.on.grn{ background:rgba(60,255,154,.98); border-color:rgba(60,255,154,.75); box-shadow:0 0 20px rgba(60,255,154,.55); }
    .light.on.red{ background:rgba(255,76,106,.98); border-color:rgba(255,76,106,.75); box-shadow:0 0 20px rgba(255,76,106,.55); }

    .statusBox{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width:160px;
    }
    .statusBig{
      font-family:var(--mono);
      font-size:14px;
      font-weight:900;
      letter-spacing:.2px;
    }
    .statusSmall{
      font-family:var(--mono);
      font-size:12px;
      color:rgba(255,255,255,.80);
    }

    .dash{
      margin-top:auto;
      pointer-events:none;
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:10px;
      align-items:end;
    }

    .dashCard{
      background:linear-gradient(180deg, rgba(10,14,26,.72), rgba(8,10,18,.55));
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px;
      padding:10px 10px;
      backdrop-filter: blur(10px);
    }

    .cluster{
      display:grid;
      grid-template-columns: 120px 1fr;
      gap:10px;
      align-items:center;
    }

    .tach{
      width:120px; height:120px;
      position:relative;
    }
    .tach svg{ width:120px; height:120px; display:block; }
    .tach .readout{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      gap:2px;
      text-align:center;
    }
    .rpmVal{ font-family:var(--mono); font-weight:900; font-size:18px; }
    .rpmLbl{ font-size:11px; color:rgba(255,255,255,.75); }

    .numbers{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:8px;
    }
    .num{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.05);
      border-radius:14px;
      padding:8px 8px;
      display:flex;
      flex-direction:column;
      gap:3px;
      min-width:0;
    }
    .num .k{ font-size:11px; color:rgba(255,255,255,.70); }
    .num .v{ font-family:var(--mono); font-weight:900; font-size:16px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

    .sessionRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
    }
    .sessionRow .num{ padding:10px 10px; }

    /* Controls */
    .controls{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:10px;
      min-height:0;
    }
    .controls .cardBody{
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    label{
      font-size:11px;
      color:rgba(255,255,255,.75);
      display:block;
      margin-bottom:6px;
    }
    select, input[type="number"], input[type="text"]{
      width:100%;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 10px;
      border-radius:12px;
      font-size:14px;
      outline:none;
      font-family:var(--sans);
    }
    .tiny{
      font-size:12px;
      padding:8px 9px;
      border-radius:10px;
    }

    .gearTable{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:14px;
      overflow:hidden;
    }
    .gearHead, .gearRow{
      display:grid;
      grid-template-columns: 48px 1fr;
      gap:8px;
      align-items:center;
      padding:8px 10px;
    }
    .gearHead{
      background:rgba(255,255,255,.04);
      border-bottom:1px solid rgba(255,255,255,.08);
      font-size:11px;
      color:rgba(255,255,255,.75);
    }
    .gearRow{
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .gearRow:last-child{ border-bottom:none; }
    .gearRow .g{
      font-family:var(--mono);
      font-weight:900;
      text-align:center;
      color:rgba(255,255,255,.9);
    }
    .gearRow input{
      font-family:var(--mono);
      letter-spacing:.2px;
    }

    .controlPads{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      align-items:stretch;
      flex:1;
      min-height:0;
    }
    .pad{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
    }
    .pedal{
      flex:1;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:10px;
      border-radius:22px;
      border:1px solid rgba(255,255,255,.10);
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      box-shadow: inset 0 -20px 40px rgba(0,0,0,.35);
      user-select:none;
      -webkit-user-select:none;
    }
    .pedal.throttle{
      background:linear-gradient(180deg, rgba(60,255,154,.16), rgba(255,255,255,.03));
      border-color:rgba(60,255,154,.22);
    }
    .pedal.brake{
      background:linear-gradient(180deg, rgba(255,76,106,.12), rgba(255,255,255,.03));
      border-color:rgba(255,76,106,.22);
      opacity:.35;
      filter:saturate(.85);
    }
    .pedalLabel{
      font-weight:900;
      letter-spacing:.8px;
      font-size:14px;
      text-transform:uppercase;
    }
    .pedalHint{
      font-size:12px;
      color:rgba(255,255,255,.75);
      text-align:center;
      padding:0 10px;
    }

    .shifter{
      display:grid;
      grid-template-rows: 1fr 1fr;
      gap:10px;
      height:100%;
    }
    .shiftBtn{
      border-radius:22px;
      border:1px solid rgba(255,255,255,.10);
      background:linear-gradient(180deg, rgba(89,214,255,.14), rgba(255,255,255,.03));
      display:flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      font-weight:900;
      font-size:16px;
      user-select:none;
      -webkit-user-select:none;
    }
    .shiftBtn:active{ transform:translateY(1px); }
    .shiftSub{
      font-family:var(--mono);
      font-size:12px;
      color:rgba(255,255,255,.75);
      font-weight:700;
    }

    .scroll{
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      min-height:0;
      padding-right:4px;
    }
    .scroll::-webkit-scrollbar{ width:6px; }
    .scroll::-webkit-scrollbar-thumb{ background:rgba(255,255,255,.12); border-radius:999px; }

    .leader{
      width:100%;
      border-collapse:collapse;
      font-size:12px;
      overflow:hidden;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
    }
    .leader th, .leader td{
      padding:8px 8px;
      border-bottom:1px solid rgba(255,255,255,.06);
      text-align:left;
      vertical-align:top;
    }
    .leader th{
      font-size:11px;
      color:rgba(255,255,255,.75);
      background:rgba(255,255,255,.04);
    }
    .leader tr:last-child td{ border-bottom:none; }
    .right{ text-align:right; }
    .center{ text-align:center; }

    .toast{
      position:absolute;
      left:50%;
      bottom:10px;
      transform:translateX(-50%);
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      padding:8px 12px;
      font-size:12px;
      color:rgba(255,255,255,.92);
      backdrop-filter: blur(10px);
      pointer-events:none;
      opacity:0;
      transition:opacity .18s ease, transform .18s ease;
      box-shadow:var(--shadow);
      max-width:92%;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .toast.show{
      opacity:1;
      transform:translateX(-50%) translateY(-2px);
    }

    @media (max-height: 750px){
      .main{ grid-template-rows: 1.15fr 1.05fr; }
      .tach{ width:110px; height:110px; }
      .tach svg{ width:110px; height:110px; }
      .cluster{ grid-template-columns: 110px 1fr; }
    }
  </style>
</head>
<body>
<div class="app">
  <div class="topbar">
    <div class="card" style="flex:1;">
      <div class="cardHeader">
        <div class="title">üèÅ Drag Simulator <span class="badge">Portrait</span></div>
        <div class="pillRow">
          <button id="btnNewSession" class="btn btnPrimary">New session</button>
          <button id="btnEndSession" class="btn btnGood">End & save</button>
          <button id="btnResetLB" class="btn btnBad">Reset LB</button>
        </div>
      </div>
      <div style="padding:8px 12px; display:flex; gap:10px; align-items:center; justify-content:space-between;">
        <div class="muted">Hold <span class="mono">THROTTLE</span>. Shift manually. Jump start = <span class="mono">DQ</span>.</div>
        <div class="muted mono" id="simHz">dt 0.016s</div>
      </div>
    </div>
  </div>

  <div class="main">
    <!-- VIEW -->
    <div class="card view">
      <canvas id="road"></canvas>

      <div class="hud">
        <div class="hudTop">
          <div class="treeWrap">
            <div class="tree" aria-label="Christmas Tree">
              <!-- Left lane -->
              <div id="L_pre"  class="light"></div><div id="R_pre"  class="light"></div>
              <div id="L_stage" class="light"></div><div id="R_stage" class="light"></div>
              <div id="L_a1"   class="light"></div><div id="R_a1"   class="light"></div>
              <div id="L_a2"   class="light"></div><div id="R_a2"   class="light"></div>
              <div id="L_a3"   class="light"></div><div id="R_a3"   class="light"></div>
              <div id="L_grn"  class="light"></div><div id="R_grn"  class="light"></div>
              <div id="L_red"  class="light"></div><div id="R_red"  class="light"></div>
            </div>
            <div class="statusBox">
              <div class="statusBig" id="runState">SETUP</div>
              <div class="statusSmall" id="runHint">Choose car + distance, then start.</div>
            </div>
          </div>

          <div class="treeWrap">
            <div class="statusBox" style="min-width:210px;">
              <div class="statusBig" id="carName">‚Äî</div>
              <div class="statusSmall" id="carMeta">‚Äî</div>
            </div>
          </div>
        </div>

        <div class="dash">
          <div class="dashCard">
            <div class="cluster">
              <div class="tach">
                <svg viewBox="0 0 120 120">
                  <defs>
                    <linearGradient id="g1" x1="0" y1="0" x2="1" y2="1">
                      <stop offset="0" stop-color="rgba(89,214,255,.9)"></stop>
                      <stop offset="1" stop-color="rgba(60,255,154,.9)"></stop>
                    </linearGradient>
                  </defs>
                  <circle cx="60" cy="60" r="46" fill="rgba(255,255,255,.04)" stroke="rgba(255,255,255,.08)" stroke-width="10"></circle>
                  <path id="tachArc" d="" fill="none" stroke="url(#g1)" stroke-width="10" stroke-linecap="round"></path>
                  <path id="tachRedArc" d="" fill="none" stroke="rgba(255,76,106,.9)" stroke-width="10" stroke-linecap="round" opacity=".0"></path>
                </svg>
                <div class="readout">
                  <div class="rpmVal" id="rpmRead">0</div>
                  <div class="rpmLbl">RPM</div>
                </div>
              </div>
              <div class="numbers">
                <div class="num">
                  <div class="k">Speed</div>
                  <div class="v"><span id="spdRead">0</span> <span class="muted">km/h</span></div>
                </div>
                <div class="num">
                  <div class="k">Gear</div>
                  <div class="v"><span id="gearRead">N</span> <span class="muted">/</span> <span id="gearMax" class="muted">‚Äî</span></div>
                </div>
                <div class="num">
                  <div class="k">Distance</div>
                  <div class="v"><span id="distRead">0</span> <span class="muted">m</span></div>
                </div>
              </div>
            </div>
          </div>

          <div class="dashCard">
            <div class="sessionRow">
              <div class="num">
                <div class="k">Timer</div>
                <div class="v"><span id="timeRead">0.000</span> <span class="muted">s</span></div>
              </div>
              <div class="num">
                <div class="k">Best (session)</div>
                <div class="v"><span id="bestRead">‚Äî</span></div>
              </div>
              <div class="num">
                <div class="k">Œî vs Best</div>
                <div class="v"><span id="deltaRead">‚Äî</span></div>
              </div>
              <div class="num">
                <div class="k">Trap speed</div>
                <div class="v"><span id="trapRead">‚Äî</span></div>
              </div>
            </div>
          </div>
        </div>

        <div class="toast" id="toast"></div>
      </div>
    </div>

    <!-- CONTROLS -->
    <div class="controls">
      <!-- Setup + tuning -->
      <div class="card" style="min-height:0;">
        <div class="cardHeader">
          <div class="title">‚öôÔ∏è Setup & Gear Tuning</div>
          <div class="pillRow">
            <button id="btnApply" class="btn btnPrimary">Apply</button>
            <button id="btnStart" class="btn btnGood">Stage / Start</button>
          </div>
        </div>

        <div class="cardBody scroll">
          <div class="grid2">
            <div>
              <label>Distance</label>
              <select id="distanceSel"></select>
            </div>
            <div>
              <label>Car</label>
              <select id="carSel"></select>
            </div>
          </div>

          <div class="grid2">
            <div>
              <label>Gear preset (per distance)</label>
              <select id="presetSel"></select>
            </div>
            <div>
              <label>Final drive (editable)</label>
              <input id="finalDrive" type="number" step="0.01" min="2.0" max="6.0" />
            </div>
          </div>

          <div class="grid2">
            <div class="gearTable" style="grid-column:1 / -1;">
              <div class="gearHead">
                <div class="center">Gear</div>
                <div>Ratio (:1)</div>
              </div>
              <div id="gearRows"></div>
            </div>
          </div>

          <div class="grid2">
            <div>
              <label>Shift cut time (s) (manual realism)</label>
              <input id="shiftTime" type="number" step="0.01" min="0.05" max="0.40" />
            </div>
            <div>
              <label>Tree type</label>
              <select id="treeType">
                <option value="sportsman">Sportsman (0.5s ambers)</option>
                <option value="pro">Pro (all ambers, 0.4s to green)</option>
              </select>
            </div>
          </div>

          <div class="muted" style="line-height:1.35;">
            Notes:
            <span class="mono">OEM ratios</span> for the two Mustang builds use Ford‚Äôs published 2024 Mustang specs; GT3 PDK uses Porsche‚Äôs 911 GT3 (PDK) datasheet.
            Aero drag + rolling resistance are simulated; no traction control and grip is effectively ‚Äúmax‚Äù.
          </div>

          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
            <button id="btnRevert" class="btn">Revert preset</button>
            <button id="btnQuickRun" class="btn">Quick run (auto-reset)</button>
          </div>

          <div class="card" style="margin-top:6px;">
            <div class="cardHeader">
              <div class="title">üèÜ Leaderboard (local)</div>
            </div>
            <div style="padding:10px;">
              <table class="leader">
                <thead>
                  <tr>
                    <th>#</th>
                    <th>Name</th>
                    <th>Car</th>
                    <th class="right">Dist</th>
                    <th class="right">Time</th>
                    <th class="right">Trap</th>
                    <th class="right">Date</th>
                  </tr>
                </thead>
                <tbody id="lbBody"></tbody>
              </table>
              <div class="muted" style="margin-top:8px;">
                Saved when you <span class="mono">End & save</span> a session (stores best run of that session).
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Driving controls -->
      <div class="card" style="min-height:0;">
        <div class="cardHeader">
          <div class="title">üïπÔ∏è Controls</div>
          <div class="pillRow">
            <button id="btnRestartRun" class="btn">Restart run</button>
            <button id="btnNextRun" class="btn btnPrimary">Next run</button>
          </div>
        </div>
        <div class="cardBody">
          <div class="controlPads">
            <div class="pad">
              <div class="pedal throttle" id="throttlePad">
                <div class="pedalLabel">THROTTLE</div>
                <div class="pedalHint">Hold to accelerate<br><span class="mono">Jump start = DQ</span></div>
              </div>
              <div class="pedal brake">
                <div class="pedalLabel">BRAKE</div>
                <div class="pedalHint">Not used (drag mode)</div>
              </div>
            </div>
            <div class="pad">
              <div class="shifter">
                <div class="shiftBtn" id="shiftUp">
                  ‚¨ÜÔ∏è SHIFT UP
                  <div class="shiftSub">tap</div>
                </div>
                <div class="shiftBtn" id="shiftDown" style="opacity:.55; filter:saturate(.85);">
                  ‚¨áÔ∏è SHIFT DOWN
                  <div class="shiftSub">optional</div>
                </div>
              </div>
            </div>
          </div>

          <div class="muted" style="line-height:1.35;">
            Tip: launch clean, then shift near redline without bouncing the limiter.
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/**
 * Drag Simulator (single-file)
 * - 1D longitudinal physics: wheel force from engine torque * ratios / wheel radius
 * - Aero drag: 0.5*rho*CdA*v^2, rolling resistance: Crr*m*g
 * - Manual shifting with shift cut time
 * - NHRA-style tree with random activation delay (anti-guess)
 * - Session best + real-time delta, local leaderboard saved in localStorage
 */

(() => {
  // ---------- Utilities ----------
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const lerp = (a, b, t) => a + (b - a) * t;
  const smoothstep = (a, b, x) => {
    const t = clamp((x - a) / (b - a), 0, 1);
    return t * t * (3 - 2 * t);
  };
  const fmt = (n, d=3) => Number.isFinite(n) ? n.toFixed(d) : "‚Äî";
  const fmt1 = (n) => Number.isFinite(n) ? n.toFixed(1) : "‚Äî";
  const nowStr = () => new Date().toISOString().slice(0,10);

  // ---------- Distances ----------
  const DISTANCES = [
    { id: "eighth", name: "1/8 mile", meters: 201.168 },
    { id: "thousand", name: "1000 ft", meters: 304.800 },
    { id: "quarter", name: "1/4 mile", meters: 402.336 },
  ];

  // ---------- Car Data ----------
  // OEM ratios sourced from published Ford & Porsche spec sheets (values copied into presets).
  const CARS = [
    {
      id: "mustang6",
      name: "V8 Manual (6MT)",
      tagline: "RWD ‚Ä¢ 446 PS ‚Ä¢ 540 Nm",
      massKg: 1808,
      powerKW: 328,            // 446 PS ‚âà 328 kW
      peakPowerRpm: 7250,
      peakTorqueNm: 540,
      peakTorqueRpm: 5100,
      redlineRpm: 7500,
      idleRpm: 900,
      drivetrainEff: 0.90,
      wheelRadiusM: 0.335,     // ~27" tire dia
      CdA: 0.36 * 2.20,        // approx
      Crr: 0.015,
      gears: [3.237, 2.104, 1.422, 1.000, 0.814, 0.622], // Ford spec
      finalDrive: 3.73,        // Ford spec option for manual
      shiftCutS: 0.18,
      launchTargetRpm: 4200,
      presets: {
        // Presets intentionally change only final drive (common IRL tuning lever) unless you want to hand-tune ratios.
        eighth:   { name:"1/8 mile (short FD)",  finalDrive: 4.05, gears: null },
        thousand: { name:"1000 ft (mid FD)",     finalDrive: 3.90, gears: null },
        quarter:  { name:"1/4 mile (OEM)",       finalDrive: 3.73, gears: null },
        default:  { name:"Default (OEM)",        finalDrive: 3.73, gears: null },
      }
    },
    {
      id: "mustang10",
      name: "V8 Auto (10AT)",
      tagline: "RWD ‚Ä¢ 446 PS ‚Ä¢ close ratios",
      massKg: 1836,
      powerKW: 328,
      peakPowerRpm: 7250,
      peakTorqueNm: 540,
      peakTorqueRpm: 5100,
      redlineRpm: 7500,
      idleRpm: 900,
      drivetrainEff: 0.92,
      wheelRadiusM: 0.335,
      CdA: 0.36 * 2.20,
      Crr: 0.015,
      gears: [4.70, 2.99, 2.15, 1.77, 1.52, 1.28, 1.00, 0.85, 0.69, 0.64], // Ford spec
      finalDrive: 3.55, // Ford spec option
      shiftCutS: 0.12,
      launchTargetRpm: 3000,
      presets: {
        eighth:   { name:"1/8 mile (short FD)",  finalDrive: 3.90, gears: null },
        thousand: { name:"1000 ft (mid FD)",     finalDrive: 3.70, gears: null },
        quarter:  { name:"1/4 mile (OEM)",       finalDrive: 3.55, gears: null },
        default:  { name:"Default (OEM)",        finalDrive: 3.55, gears: null },
      }
    },
    {
      id: "gt3pdk",
      name: "GT3 PDK (7DCT)",
      tagline: "RWD ‚Ä¢ 510 PS ‚Ä¢ 450 Nm ‚Ä¢ 311 km/h",
      massKg: 1479,             // Porsche datasheet (DIN)
      powerKW: 375,             // Porsche datasheet
      peakPowerRpm: 8500,
      peakTorqueNm: 450,
      peakTorqueRpm: 6250,
      redlineRpm: 9000,
      idleRpm: 950,
      drivetrainEff: 0.92,
      wheelRadiusM: 0.343,      // 315/30R21-ish
      CdA: 0.72,                // Porsche datasheet: cd*A = 0.72 m^2
      Crr: 0.013,
      gears: [3.75, 2.38, 1.72, 1.34, 1.11, 0.96, 0.84], // Porsche datasheet
      finalDrive: 4.54,         // Porsche datasheet rear axle ratio
      shiftCutS: 0.10,
      launchTargetRpm: 5200,
      presets: {
        eighth:   { name:"1/8 mile (short FD)",  finalDrive: 4.85, gears: null },
        thousand: { name:"1000 ft (mid FD)",     finalDrive: 4.65, gears: null },
        quarter:  { name:"1/4 mile (OEM)",       finalDrive: 4.54, gears: null },
        default:  { name:"Default (OEM)",        finalDrive: 4.54, gears: null },
      }
    }
  ];

  // ---------- DOM ----------
  const el = (id) => document.getElementById(id);
  const road = el("road");
  const ctx = road.getContext("2d");

  const distanceSel = el("distanceSel");
  const carSel = el("carSel");
  const presetSel = el("presetSel");
  const gearRows = el("gearRows");
  const finalDriveIn = el("finalDrive");
  const shiftTimeIn = el("shiftTime");
  const treeTypeSel = el("treeType");

  const btnApply = el("btnApply");
  const btnStart = el("btnStart");
  const btnRevert = el("btnRevert");
  const btnQuickRun = el("btnQuickRun");
  const btnRestartRun = el("btnRestartRun");
  const btnNextRun = el("btnNextRun");
  const btnNewSession = el("btnNewSession");
  const btnEndSession = el("btnEndSession");
  const btnResetLB = el("btnResetLB");

  const throttlePad = el("throttlePad");
  const shiftUp = el("shiftUp");
  const shiftDown = el("shiftDown");

  const runState = el("runState");
  const runHint = el("runHint");
  const carName = el("carName");
  const carMeta = el("carMeta");

  const rpmRead = el("rpmRead");
  const spdRead = el("spdRead");
  const gearRead = el("gearRead");
  const gearMax = el("gearMax");
  const distRead = el("distRead");
  const timeRead = el("timeRead");
  const bestRead = el("bestRead");
  const deltaRead = el("deltaRead");
  const trapRead = el("trapRead");
  const simHz = el("simHz");

  const tachArc = el("tachArc");
  const tachRedArc = el("tachRedArc");
  const toast = el("toast");

  const lbBody = el("lbBody");

  // Tree lights (two lanes mirrored for visuals)
  const L = {
    pre: el("L_pre"), stage: el("L_stage"),
    a1: el("L_a1"), a2: el("L_a2"), a3: el("L_a3"),
    grn: el("L_grn"), red: el("L_red"),
  };
  const R = {
    pre: el("R_pre"), stage: el("R_stage"),
    a1: el("R_a1"), a2: el("R_a2"), a3: el("R_a3"),
    grn: el("R_grn"), red: el("R_red"),
  };

  // ---------- Storage ----------
  const LB_KEY = "dragSim.leaderboard.v1";
  const loadLB = () => {
    try { return JSON.parse(localStorage.getItem(LB_KEY) || "[]"); }
    catch { return []; }
  };
  const saveLB = (arr) => localStorage.setItem(LB_KEY, JSON.stringify(arr));
  let leaderboard = loadLB();

  function renderLB(){
    const rows = [...leaderboard].sort((a,b)=>a.timeS - b.timeS).slice(0, 50);
    lbBody.innerHTML = rows.map((r, i) => `
      <tr>
        <td class="mono">${i+1}</td>
        <td>${escapeHtml(r.name)}</td>
        <td>${escapeHtml(r.car)}</td>
        <td class="right mono">${escapeHtml(r.distanceName)}</td>
        <td class="right mono">${r.timeS.toFixed(3)}s</td>
        <td class="right mono">${r.trapKmh.toFixed(1)} km/h</td>
        <td class="right mono">${escapeHtml(r.date)}</td>
      </tr>
    `).join("");
  }
  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  // ---------- UI population ----------
  DISTANCES.forEach(d => {
    const opt = document.createElement("option");
    opt.value = d.id;
    opt.textContent = `${d.name} (${d.meters.toFixed(3)} m)`;
    distanceSel.appendChild(opt);
  });

  CARS.forEach(c => {
    const opt = document.createElement("option");
    opt.value = c.id;
    opt.textContent = c.name;
    carSel.appendChild(opt);
  });

  // ---------- Game / Physics State ----------
  const physics = {
    rho: 1.225,
    g: 9.81,
  };

  // Session state
  let session = {
    active: false,
    runs: [],
    bestTimeS: Infinity,
    bestTrapKmh: NaN,
    bestCrossKmh: NaN,
    bestRun: null,
  };

  // Run state machine
  const RUN = {
    SETUP: "SETUP",
    STAGED: "STAGED",
    TREE: "TREE",
    GREEN: "GREEN",
    RUNNING: "RUNNING",
    FINISHED: "FINISHED",
    DQ: "DQ"
  };

  let state = RUN.SETUP;

  // Current config (mutable)
  let cfg = {
    distance: DISTANCES[2],
    car: CARS[0],
    gears: [],
    finalDrive: 1,
    shiftCutS: 0.18,
    treeType: "sportsman",
  };

  // Vehicle dynamic state
  let veh = {
    x: 0,             // meters
    v: 0,             // m/s
    a: 0,             // m/s^2
    gearIndex: -1,    // -1 neutral, 0..n-1 gears
    rpm: 900,
    throttle: 0,
    shifting: 0,      // seconds remaining (shift cut)
    dq: false,
    finished: false,
    elapsed: 0,
    trapV: 0,         // m/s at finish
  };

  // Tree timing
  let tree = {
    t: 0,
    delay: 0,
    started: false,
    green: false,
  };

  // ---------- Engine model ----------
  // Creates a plausible torque curve anchored by peak torque + peak power + redline.
  function engineTorqueNm(car, rpm, throttle){
    rpm = clamp(rpm, car.idleRpm, car.redlineRpm * 1.2);

    // Torque implied at peak power rpm: T = P*9550 / rpm
    const tAtPower = (car.powerKW * 9550) / car.peakPowerRpm;

    // Low rpm ramp (idle -> 2000)
    const low = smoothstep(car.idleRpm, 2000, rpm);
    const baseLow = lerp(0.55, 0.88, low); // normalized

    // Rise to peak torque
    const rise = smoothstep(2000, car.peakTorqueRpm, rpm);
    const mid = lerp(baseLow, 1.00, rise);

    // Fall from peak torque to peak power torque and then to redline torque
    const fall1 = smoothstep(car.peakTorqueRpm, car.peakPowerRpm, rpm);
    const t1 = lerp(car.peakTorqueNm, tAtPower, fall1);

    // Past peak power, taper down a bit towards redline
    const tAtRed = tAtPower * 0.90; // typical NA engines soften near limiter
    const fall2 = smoothstep(car.peakPowerRpm, car.redlineRpm, rpm);
    const t2 = lerp(tAtPower, tAtRed, fall2);

    // Combine: below peak torque use car.peakTorqueNm * mid; between torque->power blend towards t1; beyond power use t2
    let t = car.peakTorqueNm * mid;
    if (rpm >= car.peakTorqueRpm && rpm <= car.peakPowerRpm) t = t1;
    if (rpm > car.peakPowerRpm) t = t2;

    // Throttle scaling
    t *= clamp(throttle, 0, 1);

    // Limiter: when bouncing redline, cut torque hard
    if (rpm >= car.redlineRpm) {
      const over = clamp((rpm - car.redlineRpm) / 400, 0, 1);
      t *= lerp(0.35, 0.10, over);
    }

    return t;
  }

  function wheelForceN(car, rpm, throttle, gearRatio, finalDrive){
    const Te = engineTorqueNm(car, rpm, throttle);
    const Tw = Te * gearRatio * finalDrive * car.drivetrainEff;
    return Tw / car.wheelRadiusM;
  }

  function aeroDragN(car, v){
    return 0.5 * physics.rho * car.CdA * v * v;
  }
  function rollingN(car){
    return car.Crr * car.massKg * physics.g;
  }

  // Clutch slip model for launch realism (max grip, no TC):
  // At very low speeds, the drivetrain is not fully "locked" to allow engine to sit near launchTargetRpm.
  function couplingFactor(v){
    // 0 at standstill, ~1 by ~12 m/s (~43 km/h)
    return smoothstep(0.0, 12.0, v);
  }

  // ---------- Geometry helpers for tach arc ----------
  function polar(cx, cy, r, angDeg){
    const a = (angDeg - 90) * Math.PI/180;
    return { x: cx + r*Math.cos(a), y: cy + r*Math.sin(a) };
  }
  function arcPath(cx, cy, r, a0, a1){
    const p0 = polar(cx,cy,r,a0);
    const p1 = polar(cx,cy,r,a1);
    const large = (a1 - a0) > 180 ? 1 : 0;
    return `M ${p0.x.toFixed(3)} ${p0.y.toFixed(3)} A ${r} ${r} 0 ${large} 1 ${p1.x.toFixed(3)} ${p1.y.toFixed(3)}`;
  }

  // ---------- Toast ----------
  let toastTimer = 0;
  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add("show");
    toastTimer = 1.6;
  }

  // ---------- Tree lights ----------
  function clearTree(){
    Object.values(L).forEach(x=>x.className="light");
    Object.values(R).forEach(x=>x.className="light");
  }
  function setLight(elm, on, cls){
    elm.className = "light" + (on ? (" on " + cls) : "");
  }
  function updateTreeVisual(){
    // Mirror lane visuals for style (single-player).
    setLight(L.pre,  state !== RUN.SETUP, "pre");  setLight(R.pre,  state !== RUN.SETUP, "pre");
    setLight(L.stage, state === RUN.STAGED || state === RUN.TREE || state === RUN.GREEN || state === RUN.RUNNING, "stage");
    setLight(R.stage, state === RUN.STAGED || state === RUN.TREE || state === RUN.GREEN || state === RUN.RUNNING, "stage");

    if (state === RUN.TREE || state === RUN.GREEN || state === RUN.RUNNING || state === RUN.FINISHED || state === RUN.DQ){
      const t = tree.t;
      const type = cfg.treeType;
      if (type === "sportsman"){
        // ambers at 0.0, 0.5, 1.0 then green at 1.5
        setLight(L.a1, t >= 0.0, "amb"); setLight(R.a1, t >= 0.0, "amb");
        setLight(L.a2, t >= 0.5, "amb"); setLight(R.a2, t >= 0.5, "amb");
        setLight(L.a3, t >= 1.0, "amb"); setLight(R.a3, t >= 1.0, "amb");
        setLight(L.grn, t >= 1.5 && !veh.dq, "grn"); setLight(R.grn, t >= 1.5 && !veh.dq, "grn");
      } else {
        // pro tree: all ambers together, green after 0.4
        setLight(L.a1, t >= 0.0, "amb"); setLight(R.a1, t >= 0.0, "amb");
        setLight(L.a2, t >= 0.0, "amb"); setLight(R.a2, t >= 0.0, "amb");
        setLight(L.a3, t >= 0.0, "amb"); setLight(R.a3, t >= 0.0, "amb");
        setLight(L.grn, t >= 0.4 && !veh.dq, "grn"); setLight(R.grn, t >= 0.4 && !veh.dq, "grn");
      }
    } else {
      setLight(L.a1,false,""); setLight(R.a1,false,"");
      setLight(L.a2,false,""); setLight(R.a2,false,"");
      setLight(L.a3,false,""); setLight(R.a3,false,"");
      setLight(L.grn,false,""); setLight(R.grn,false,"");
    }

    setLight(L.red, veh.dq, "red");
    setLight(R.red, veh.dq, "red");
  }

  function treeGreenTime(){
    return (cfg.treeType === "sportsman") ? 1.5 : 0.4;
  }

  // ---------- Rendering road (simple first-person motion cues) ----------
  let roadPhase = 0;
  function resizeCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = road.getBoundingClientRect();
    road.width = Math.floor(rect.width * dpr);
    road.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  }
  window.addEventListener("resize", resizeCanvas, {passive:true});
  resizeCanvas();

  function drawRoad(){
    const w = road.getBoundingClientRect().width;
    const h = road.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,h);

    // sky glow
    const g = ctx.createRadialGradient(w*0.5, h*0.1, 10, w*0.5, h*0.1, h*1.1);
    g.addColorStop(0, "rgba(89,214,255,.10)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // Road trapezoid
    const topY = h*0.22;
    const botY = h*1.02;
    const topW = w*0.08;
    const botW = w*1.08;
    const cx = w*0.5;

    ctx.beginPath();
    ctx.moveTo(cx-topW/2, topY);
    ctx.lineTo(cx+topW/2, topY);
    ctx.lineTo(cx+botW/2, botY);
    ctx.lineTo(cx-botW/2, botY);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,255,255,.03)";
    ctx.fill();

    // Lane lines
    ctx.strokeStyle = "rgba(255,255,255,.14)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx-topW/2, topY);
    ctx.lineTo(cx-botW/2, botY);
    ctx.moveTo(cx+topW/2, topY);
    ctx.lineTo(cx+botW/2, botY);
    ctx.stroke();

    // Center dashes (speed cues)
    const speed = veh.v; // m/s
    const dashRate = clamp(speed / 55, 0, 1); // 0..~200 km/h
    roadPhase += (0.6 + 4.0*dashRate) * dt; // dt global
    const phase = (roadPhase % 1);

    const dashCount = 14;
    for (let i=0;i<dashCount;i++){
      const t = (i / dashCount + phase) % 1;
      // Perspective: y goes from top to bottom non-linear
      const py = lerp(topY, botY, t*t); // ease-in perspective
      const px = cx;
      const dashLen = lerp(6, 42, t);  // longer near bottom
      const dashW = lerp(1.5, 4.5, t);
      ctx.strokeStyle = `rgba(255,255,255,${lerp(0.06, 0.22, t)})`;
      ctx.lineWidth = dashW;
      ctx.beginPath();
      ctx.moveTo(px, py - dashLen/2);
      ctx.lineTo(px, py + dashLen/2);
      ctx.stroke();
    }

    // Speed bars (peripheral sense)
    const bars = 18;
    const barAlpha = 0.10 + 0.25*dashRate;
    for (let i=0;i<bars;i++){
      const t = (i / bars + (phase*0.7)) % 1;
      const py = lerp(topY, botY, Math.pow(t, 1.6));
      const spread = lerp(topW*0.8, botW*0.55, t);
      const lw = lerp(1, 6, t);
      ctx.strokeStyle = `rgba(89,214,255,${barAlpha * (0.15 + 0.85*t)})`;
      ctx.lineWidth = lw;
      ctx.beginPath();
      ctx.moveTo(cx - spread*0.35, py);
      ctx.lineTo(cx - spread*0.55, py + lerp(3, 22, t));
      ctx.stroke();
      ctx.strokeStyle = `rgba(60,255,154,${barAlpha * (0.12 + 0.75*t)})`;
      ctx.beginPath();
      ctx.moveTo(cx + spread*0.35, py);
      ctx.lineTo(cx + spread*0.55, py + lerp(3, 22, t));
      ctx.stroke();
    }

    // Subtle vignette
    const v = ctx.createRadialGradient(cx, h*0.6, h*0.1, cx, h*0.6, h*0.85);
    v.addColorStop(0, "rgba(0,0,0,0)");
    v.addColorStop(1, "rgba(0,0,0,.55)");
    ctx.fillStyle = v;
    ctx.fillRect(0,0,w,h);
  }

  // ---------- Config UI ----------
  function getSelectedCar(){
    return CARS.find(c => c.id === carSel.value) || CARS[0];
  }
  function getSelectedDistance(){
    return DISTANCES.find(d => d.id === distanceSel.value) || DISTANCES[2];
  }

  function buildPresetList(){
    presetSel.innerHTML = "";
    const car = getSelectedCar();
    const dist = getSelectedDistance();
    const mapKey = dist.id;

    const presets = [
      { key: "default", ...car.presets.default },
      { key: mapKey, ...car.presets[mapKey] }
    ];

    // Ensure unique by name/key
    const unique = [];
    const seen = new Set();
    for (const p of presets){
      const k = p.key + "|" + p.name;
      if (!seen.has(k)) { seen.add(k); unique.push(p); }
    }

    unique.forEach(p=>{
      const opt = document.createElement("option");
      opt.value = p.key;
      opt.textContent = p.name;
      presetSel.appendChild(opt);
    });
  }

  function buildGearInputs(gearCount){
    gearRows.innerHTML = "";
    for (let i=0;i<gearCount;i++){
      const row = document.createElement("div");
      row.className = "gearRow";
      row.innerHTML = `
        <div class="g">${i+1}</div>
        <input class="tiny mono" id="g_${i}" type="number" step="0.001" min="0.200" max="10.000" />
      `;
      gearRows.appendChild(row);
    }
  }

  function applyCarToUI(car){
    carName.textContent = car.name;
    carMeta.textContent = `${car.tagline} ‚Ä¢ ${car.massKg} kg ‚Ä¢ redline ${car.redlineRpm} rpm`;

    gearMax.textContent = car.gears.length;

    buildGearInputs(car.gears.length);
  }

  function loadPresetIntoInputs({ car, distId, presetKey }){
    const preset = (presetKey === "default")
      ? car.presets.default
      : (car.presets[distId] || car.presets.default);

    // default ratios are OEM unless preset provides alt gears
    const gears = preset.gears ? preset.gears.slice() : car.gears.slice();
    const fd = preset.finalDrive ?? car.finalDrive;

    finalDriveIn.value = fd.toFixed(2);
    for (let i=0;i<gears.length;i++){
      const inp = el(`g_${i}`);
      if (inp) inp.value = gears[i].toFixed(3);
    }
    shiftTimeIn.value = (car.shiftCutS).toFixed(2);
  }

  function readInputsToCfg(){
    const car = getSelectedCar();
    const dist = getSelectedDistance();

    const gears = [];
    for (let i=0;i<car.gears.length;i++){
      const v = parseFloat(el(`g_${i}`).value);
      if (!Number.isFinite(v) || v <= 0) return { ok:false, msg:`Invalid gear ratio at gear ${i+1}` };
      gears.push(v);
    }
    // sanity: ratios should generally decrease with gear number
    for (let i=1;i<gears.length;i++){
      if (gears[i] >= gears[i-1]) {
        return { ok:false, msg:`Gear ${i+1} ratio should be lower than gear ${i} (realistic descending ratios).` };
      }
    }

    const fd = parseFloat(finalDriveIn.value);
    if (!Number.isFinite(fd) || fd < 2.0 || fd > 6.0) return { ok:false, msg:"Final drive out of range." };

    const sc = parseFloat(shiftTimeIn.value);
    if (!Number.isFinite(sc) || sc < 0.05 || sc > 0.40) return { ok:false, msg:"Shift cut time out of range." };

    cfg.distance = dist;
    cfg.car = car;
    cfg.gears = gears;
    cfg.finalDrive = fd;
    cfg.shiftCutS = sc;
    cfg.treeType = treeTypeSel.value;

    return { ok:true };
  }

  // ---------- Run control ----------
  function resetRun(){
    veh.x = 0; veh.v = 0; veh.a = 0;
    veh.gearIndex = -1;
    veh.rpm = cfg.car.idleRpm;
    veh.throttle = 0;
    veh.shifting = 0;
    veh.dq = false;
    veh.finished = false;
    veh.elapsed = 0;
    veh.trapV = 0;

    tree.t = 0;
    tree.delay = 0;
    tree.started = false;
    tree.green = false;

    clearTree();
    updateTreeVisual();

    state = RUN.SETUP;
    runState.textContent = "SETUP";
    runHint.textContent = "Choose car + distance, then stage.";
    trapRead.textContent = "‚Äî";
  }

  function stageStart(){
    const res = readInputsToCfg();
    if (!res.ok){ showToast(res.msg); return; }

    // Engage first gear by default when staged
    veh.gearIndex = 0;
    veh.rpm = Math.max(cfg.car.idleRpm, 1400);
    veh.x = 0; veh.v = 0; veh.a = 0;
    veh.elapsed = 0;
    veh.trapV = 0;
    veh.dq = false;
    veh.finished = false;
    veh.shifting = 0;

    state = RUN.STAGED;
    runState.textContent = "STAGED";
    runHint.textContent = "Hold throttle ONLY after green.";

    // Random anti-guess delay: start sequence within ~0.25..1.30s after staging.
    tree.delay = 0.25 + Math.random() * 1.05;
    tree.t = 0;
    tree.started = false;
    tree.green = false;

    clearTree();
    updateTreeVisual();
  }

  function startTreeSequence(){
    state = RUN.TREE;
    runState.textContent = "TREE";
    runHint.textContent = "Wait for green‚Ä¶";
    tree.started = true;
    tree.t = 0;
    tree.green = false;
  }

  function toGreenIfReady(){
    const gt = treeGreenTime();
    if (tree.t >= gt) {
      tree.green = true;
      if (!veh.dq) {
        state = RUN.GREEN;
        runState.textContent = "GREEN";
        runHint.textContent = "GO!";
      }
    }
  }

  function startRunningIfMoving(){
    // Start elapsed at green (drag timing convention)
    if (state === RUN.GREEN) {
      // If player throttles after green, we move to RUNNING immediately
      if (veh.throttle > 0) {
        state = RUN.RUNNING;
        runState.textContent = "RUN";
        runHint.textContent = "Shift manually.";
      }
    }
  }

  function finishRun(){
    veh.finished = true;
    state = RUN.FINISHED;
    runState.textContent = "FINISH";
    runHint.textContent = `Trap ${fmt1(veh.trapV * 3.6)} km/h`;
    trapRead.textContent = `${fmt1(veh.trapV * 3.6)} km/h`;

    if (!veh.dq) {
      session.runs.push({
        timeS: veh.elapsed,
        trapKmh: veh.trapV * 3.6,
        crossKmh: veh.trapV * 3.6,
        carId: cfg.car.id,
        carName: cfg.car.name,
        distId: cfg.distance.id,
        distName: cfg.distance.name
      });

      if (veh.elapsed < session.bestTimeS) {
        session.bestTimeS = veh.elapsed;
        session.bestTrapKmh = veh.trapV * 3.6;
        session.bestCrossKmh = veh.trapV * 3.6;
        session.bestRun = session.runs[session.runs.length - 1];
      }
      bestRead.textContent = `${session.bestTimeS.toFixed(3)} s`;
      showToast(`Run: ${veh.elapsed.toFixed(3)}s ‚Ä¢ Trap: ${fmt1(veh.trapV*3.6)} km/h`);
    } else {
      showToast("DQ: Jump start");
    }
  }

  // ---------- Inputs: Throttle + Shifts ----------
  function setThrottle(on){
    veh.throttle = on ? 1 : 0;

    // Jump start logic:
    if ((state === RUN.STAGED || state === RUN.TREE) && veh.throttle > 0 && !tree.green){
      veh.dq = true;
      state = RUN.DQ;
      runState.textContent = "DQ";
      runHint.textContent = "Jump start.";
      showToast("Jump start ‚Äî DISQUALIFIED");
    }

    // On green, throttle begins the run
    if (tree.green && (state === RUN.GREEN || state === RUN.TREE) && !veh.dq){
      startRunningIfMoving();
    }
  }

  function shift(direction){
    if (veh.dq || veh.finished) return;
    if (!(state === RUN.RUNNING || state === RUN.GREEN)) return;

    const maxG = cfg.gears.length;
    const newIndex = clamp(veh.gearIndex + direction, 0, maxG-1);
    if (newIndex === veh.gearIndex) return;

    // Optional downshift exists, but punishes if too high rpm
    veh.gearIndex = newIndex;
    veh.shifting = cfg.shiftCutS;

    // Snap rpm towards new coupled rpm (rev-match for realism)
    const wheelRpm = (veh.v / (2*Math.PI*cfg.car.wheelRadiusM)) * 60;
    const coupled = wheelRpm * cfg.gears[veh.gearIndex] * cfg.finalDrive;
    // If coupled rpm is below idle, allow some slip so we don't stall
    veh.rpm = Math.max(cfg.car.idleRpm, coupled);

    showToast(direction > 0 ? "Shift up" : "Shift down");
  }

  // Touch-safe pointer handling
  function bindHold(element, onDown, onUp){
    let pressed = false;
    const down = (e) => {
      e.preventDefault();
      pressed = true;
      onDown();
    };
    const up = (e) => {
      e.preventDefault();
      if (!pressed) return;
      pressed = false;
      onUp();
    };
    element.addEventListener("pointerdown", down, {passive:false});
    element.addEventListener("pointerup", up, {passive:false});
    element.addEventListener("pointercancel", up, {passive:false});
    element.addEventListener("pointerleave", up, {passive:false});
  }

  bindHold(throttlePad, () => setThrottle(true), () => setThrottle(false));

  shiftUp.addEventListener("pointerdown", (e)=>{ e.preventDefault(); shift(+1); }, {passive:false});
  shiftDown.addEventListener("pointerdown", (e)=>{ e.preventDefault(); shift(-1); }, {passive:false});

  // ---------- Buttons ----------
  btnApply.addEventListener("click", () => {
    const res = readInputsToCfg();
    if (!res.ok){ showToast(res.msg); return; }
    applyConfigToHUD();
    showToast("Applied");
  });

  btnStart.addEventListener("click", () => {
    if (state === RUN.SETUP || state === RUN.FINISHED || state === RUN.DQ) {
      stageStart();
    } else if (state === RUN.STAGED) {
      // Start random delay countdown; tree starts after delay
      showToast("Staged. Hold‚Ä¶");
    }
  });

  btnRevert.addEventListener("click", () => {
    const car = getSelectedCar();
    const dist = getSelectedDistance();
    loadPresetIntoInputs({ car, distId: dist.id, presetKey: presetSel.value });
    showToast("Reverted to preset");
  });

  btnQuickRun.addEventListener("click", () => {
    // Apply + stage and reset if needed
    const res = readInputsToCfg();
    if (!res.ok){ showToast(res.msg); return; }
    applyConfigToHUD();
    stageStart();
  });

  btnRestartRun.addEventListener("click", () => {
    // Keep config; just restart current run
    veh.throttle = 0;
    resetRun();
    applyConfigToHUD();
    showToast("Run reset");
  });

  btnNextRun.addEventListener("click", () => {
    // Carry config, new run
    veh.throttle = 0;
    resetRun();
    applyConfigToHUD();
    stageStart();
  });

  btnNewSession.addEventListener("click", () => {
    session = { active:true, runs:[], bestTimeS:Infinity, bestTrapKmh:NaN, bestCrossKmh:NaN, bestRun:null };
    bestRead.textContent = "‚Äî";
    deltaRead.textContent = "‚Äî";
    showToast("New session started");
    resetRun();
    applyConfigToHUD();
  });

  btnEndSession.addEventListener("click", () => {
    if (!session.runs.length || !Number.isFinite(session.bestTimeS)) {
      showToast("No valid runs to save");
      return;
    }
    const name = prompt("Enter your name for the leaderboard:", "Player");
    if (!name) { showToast("Cancelled"); return; }

    const best = session.bestRun;
    leaderboard.push({
      name: name.trim().slice(0, 24),
      car: best.carName,
      distanceName: best.distName,
      timeS: best.timeS,
      trapKmh: best.trapKmh,
      date: nowStr()
    });
    saveLB(leaderboard);
    renderLB();

    showToast("Saved to leaderboard");
    // End session but keep state
  });

  btnResetLB.addEventListener("click", () => {
    if (!confirm("Reset leaderboard (local) ?")) return;
    leaderboard = [];
    saveLB(leaderboard);
    renderLB();
    showToast("Leaderboard cleared");
  });

  // ---------- Selection change handlers ----------
  function onSelectionChanged(){
    const car = getSelectedCar();
    const dist = getSelectedDistance();

    applyCarToUI(car);
    buildPresetList();
    // default to "default (OEM)"
    presetSel.value = "default";
    loadPresetIntoInputs({ car, distId: dist.id, presetKey: "default" });

    // Apply to cfg too (but not forcing until Apply/Stage is pressed)
    applyConfigToHUDPreview(car, dist);
  }

  carSel.addEventListener("change", onSelectionChanged);
  distanceSel.addEventListener("change", () => {
    buildPresetList();
    presetSel.value = "default";
    const car = getSelectedCar();
    const dist = getSelectedDistance();
    loadPresetIntoInputs({ car, distId: dist.id, presetKey: "default" });
    applyConfigToHUDPreview(car, dist);
  });

  presetSel.addEventListener("change", () => {
    const car = getSelectedCar();
    const dist = getSelectedDistance();
    loadPresetIntoInputs({ car, distId: dist.id, presetKey: presetSel.value });
    showToast("Preset loaded");
  });

  function applyConfigToHUDPreview(car, dist){
    carName.textContent = car.name;
    carMeta.textContent = `${car.tagline} ‚Ä¢ ${car.massKg} kg ‚Ä¢ redline ${car.redlineRpm} rpm`;
    distRead.textContent = dist.meters.toFixed(1);
    gearMax.textContent = car.gears.length;
  }

  function applyConfigToHUD(){
    carName.textContent = cfg.car.name;
    carMeta.textContent = `${cfg.car.tagline} ‚Ä¢ ${cfg.car.massKg} kg ‚Ä¢ redline ${cfg.car.redlineRpm} rpm`;
    distRead.textContent = cfg.distance.meters.toFixed(1);
    gearMax.textContent = cfg.gears.length;
  }

  // ---------- Main simulation loop ----------
  let last = performance.now();
  // fixed dt for stability
  let dt = 1/60;
  simHz.textContent = `dt ${dt.toFixed(3)}s`;

  function stepPhysics(dt){
    // Tree / state progression
    if (state === RUN.STAGED){
      // Wait random delay then begin tree sequence
      tree.delay -= dt;
      if (tree.delay <= 0 && !tree.started){
        startTreeSequence();
      }
    } else if (state === RUN.TREE || state === RUN.GREEN || state === RUN.RUNNING){
      // Run the countdown timer once started
      if (tree.started && !tree.green){
        tree.t += dt;
        toGreenIfReady();
      }
      if (tree.green && state === RUN.TREE && !veh.dq){
        state = RUN.GREEN;
        runState.textContent = "GREEN";
        runHint.textContent = "GO!";
      }
    }

    // If DQ, keep car stationary (but allow visuals)
    if (veh.dq){
      veh.throttle = 0;
    }

    // Determine gear ratio
    const inGear = veh.gearIndex >= 0;
    const gr = inGear ? cfg.gears[veh.gearIndex] : 0;

    // Coupled rpm from wheels
    const wheelRpm = (veh.v / (2*Math.PI*cfg.car.wheelRadiusM)) * 60;
    const coupledRpm = inGear ? wheelRpm * gr * cfg.finalDrive : cfg.car.idleRpm;

    // Shift cut: no drive
    let driveForce = 0;
    if (veh.shifting > 0) {
      veh.shifting = Math.max(0, veh.shifting - dt);
      // Let rpm relax toward coupled rpm during shift (rev-match / inertia)
      veh.rpm = lerp(veh.rpm, coupledRpm, 1 - Math.exp(-dt*10));
      driveForce = 0;
    } else if (inGear && (state === RUN.RUNNING || state === RUN.GREEN) && !veh.finished && !veh.dq){
      // Launch coupling
      const cf = couplingFactor(veh.v);
      const target = lerp(cfg.car.launchTargetRpm, coupledRpm, cf);
      // Engine rpm follows between launch target and coupled based on coupling
      const rpmFollow = lerp(target, coupledRpm, clamp(cf + 0.10, 0, 1));
      veh.rpm = lerp(veh.rpm, rpmFollow, 1 - Math.exp(-dt*12));

      // Compute wheel force from torque
      driveForce = wheelForceN(cfg.car, veh.rpm, veh.throttle, gr, cfg.finalDrive);

      // If rpm would fall below idle with low speed & no throttle, relax to idle
      if (veh.throttle === 0 && veh.v < 0.5) {
        veh.rpm = lerp(veh.rpm, cfg.car.idleRpm, 1 - Math.exp(-dt*6));
      }
    } else {
      // Coasting
      veh.rpm = lerp(veh.rpm, Math.max(cfg.car.idleRpm, coupledRpm), 1 - Math.exp(-dt*8));
    }

    // Resistances
    const drag = aeroDragN(cfg.car, veh.v);
    const roll = rollingN(cfg.car);

    // Net force along vehicle direction
    let net = driveForce - drag - roll;

    // Prevent creeping backwards
    if (veh.v <= 0.0 && net < 0) net = 0;

    // Integrate
    veh.a = net / cfg.car.massKg;
    veh.v = Math.max(0, veh.v + veh.a * dt);
    veh.x += veh.v * dt;

    // Timing:
    // Elapsed time starts on green (even if you wait), like real drag timing.
    if ((state === RUN.GREEN || state === RUN.RUNNING) && tree.green && !veh.finished && !veh.dq) {
      veh.elapsed += dt;
    }

    // Start RUNNING when throttle is applied on green
    if (tree.green && !veh.dq && (state === RUN.GREEN || state === RUN.TREE)) {
      startRunningIfMoving();
    }

    // Finish check
    if (!veh.finished && !veh.dq && veh.x >= cfg.distance.meters){
      veh.trapV = veh.v;
      finishRun();
    }

    // Update HUD
    updateHUD();
    updateTreeVisual();
  }

  function updateHUD(){
    // reads
    const kmh = veh.v * 3.6;
    spdRead.textContent = Math.round(kmh).toString();

    rpmRead.textContent = Math.round(veh.rpm).toString();

    const g = (veh.gearIndex < 0) ? "N" : String(veh.gearIndex + 1);
    gearRead.textContent = g;

    distRead.textContent = cfg.distance.meters.toFixed(1);

    // time & best & delta
    timeRead.textContent = veh.elapsed.toFixed(3);

    if (Number.isFinite(session.bestTimeS) && session.bestTimeS < Infinity){
      bestRead.textContent = `${session.bestTimeS.toFixed(3)} s`;
      const d = veh.elapsed - session.bestTimeS;
      // show delta only while a run is active
      if ((state === RUN.GREEN || state === RUN.RUNNING) && !veh.dq){
        const sign = d >= 0 ? "+" : "‚àí";
        deltaRead.textContent = `${sign}${Math.abs(d).toFixed(3)} s`;
      } else {
        deltaRead.textContent = "‚Äî";
      }
    } else {
      bestRead.textContent = "‚Äî";
      deltaRead.textContent = "‚Äî";
    }

    // trap shows after finish
    if (veh.finished && !veh.dq){
      trapRead.textContent = `${fmt1(veh.trapV*3.6)} km/h`;
    }

    // Tach arc
    const ratio = clamp(veh.rpm / cfg.car.redlineRpm, 0, 1.15);
    const a0 = 210;
    const a1 = lerp(210, -30, clamp(ratio, 0, 1));
    tachArc.setAttribute("d", arcPath(60,60,46,a0,a1));

    // red zone overlay (last 10% to redline)
    const rz0 = lerp(210, -30, 0.90);
    const rz1 = -30;
    tachRedArc.setAttribute("d", arcPath(60,60,46,rz0,rz1));
    const redOpacity = clamp((veh.rpm - cfg.car.redlineRpm*0.90)/(cfg.car.redlineRpm*0.10), 0, 1) * 0.75;
    tachRedArc.setAttribute("opacity", redOpacity.toFixed(3));

    // Run state
    if (state === RUN.SETUP){
      runState.textContent = "SETUP";
      runHint.textContent = "Choose car + distance, then stage.";
    } else if (state === RUN.STAGED){
      runState.textContent = "STAGED";
      runHint.textContent = "Hold‚Ä¶ green is randomized.";
    } else if (state === RUN.TREE){
      runState.textContent = "TREE";
      runHint.textContent = "Do NOT jump.";
    } else if (state === RUN.GREEN){
      runState.textContent = "GREEN";
      runHint.textContent = "GO!";
    } else if (state === RUN.RUNNING){
      runState.textContent = "RUN";
      runHint.textContent = "Shift manually.";
    } else if (state === RUN.FINISHED){
      runState.textContent = "FINISH";
      runHint.textContent = `Trap ${fmt1(veh.trapV * 3.6)} km/h`;
    } else if (state === RUN.DQ){
      runState.textContent = "DQ";
      runHint.textContent = "Jump start.";
    }

    // Toast timer
    if (toastTimer > 0){
      toastTimer -= dt;
      if (toastTimer <= 0) toast.classList.remove("show");
    }
  }

  function loop(t){
    // fixed timestep for stable physics
    const frame = (t - last) / 1000;
    last = t;
    const steps = Math.min(6, Math.max(1, Math.round(frame / dt)));
    for (let i=0;i<steps;i++){
      stepPhysics(dt);
    }
    drawRoad();
    requestAnimationFrame(loop);
  }

  // ---------- Init ----------
  function init(){
    renderLB();

    // default selections
    distanceSel.value = "quarter";
    carSel.value = "mustang6";
    onSelectionChanged();

    // apply initial cfg
    readInputsToCfg();
    applyConfigToHUD();
    resetRun();

    requestAnimationFrame(loop);
  }

  init();

})();
</script>
</body>
</html>