<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Find the Different Color</title>
  <style>
    :root{
      --bg:#0b0b0f;
      --text:#f3f3f6;
      --muted:#b7b7c2;
      --gridLine:#ffffff;
      --safeTop: env(safe-area-inset-top);
      --safeBottom: env(safe-area-inset-bottom);
      --safeLeft: env(safe-area-inset-left);
      --safeRight: env(safe-area-inset-right);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial, sans-serif; }
    button, select, input { font: inherit; }

    .app{
      min-height:100%;
      padding: calc(14px + var(--safeTop)) calc(14px + var(--safeRight)) calc(14px + var(--safeBottom)) calc(14px + var(--safeLeft));
      display:flex; flex-direction:column; gap:12px;
      user-select:none;
    }

    .topbar{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .title{ font-weight:800; letter-spacing:.2px; font-size: 18px; }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      padding: 8px 10px;
      white-space:nowrap;
    }
    .pill strong{ font-variant-numeric: tabular-nums; }
    .muted{ color: var(--muted); }

    .btn{
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.16);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      font-weight:700;
      touch-action: manipulation;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: linear-gradient(180deg, rgba(125,211,252,.22), rgba(125,211,252,.10));
      border-color: rgba(125,211,252,.35);
    }

    .panel{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding: 12px;
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .control{ display:flex; flex-direction:column; gap:6px; }
    label{
      font-size: 12px;
      color: var(--muted);
      font-weight:700;
      letter-spacing:.2px;
    }
    select, input[type="number"], input[type="range"]{
      width:100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.25);
      color: var(--text);
      outline:none;
    }
    input[type="range"]{
      padding: 10px 10px;
      height: 42px;
    }
    input[type="number"]{ -moz-appearance:textfield; }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button{ -webkit-appearance: none; margin:0; }

    .row{ display:flex; gap:10px; flex-wrap:wrap; }
    .row .btn{ flex:1; min-width: 120px; }

    .gridWrap{ flex:1; display:flex; align-items:center; justify-content:center; padding: 6px 0; }

    .board{
      width: min(92vw, 520px);
      height: min(92vw, 520px);
      max-height: calc(100vh - 360px);
      max-width: calc(100vh - 360px);
      border-radius: 18px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      position:relative;
      touch-action: manipulation;
    }

    .grid{
      width:100%;
      height:100%;
      display:grid;
      background: var(--gridLine);
    }

    .cell{
      background: #444;
      border: 1px solid var(--gridLine);
      border-left-width: 0;
      border-top-width: 0;
      touch-action: manipulation;
      position:relative;
    }

    .cell.reveal{
      outline: 4px solid rgba(255,0,0,.95);
      outline-offset: -4px;
      animation: revealFlash .35s linear infinite;
    }
    @keyframes revealFlash{
      0%{ outline-color: rgba(255,0,0,.95); }
      50%{ outline-color: rgba(255,0,0,.12); }
      100%{ outline-color: rgba(255,0,0,.95); }
    }

    .overlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,.50);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 16px;
      z-index: 10;
    }
    .card{
      width: min(520px, 92vw);
      background: rgba(20,20,32,.92);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      padding: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    .card h2{ margin: 0 0 8px 0; font-size: 18px; letter-spacing:.2px; }
    .card p{ margin: 6px 0 10px 0; color: var(--muted); line-height: 1.35; font-size: 13px; }

    .scoreBox{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .scoreItem{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px;
    }
    .scoreItem .k{ color: var(--muted); font-size: 12px; font-weight:700; }
    .scoreItem .v{ margin-top:4px; font-size: 16px; font-weight:900; font-variant-numeric: tabular-nums; }

    .flash{
      position:absolute; inset:0;
      pointer-events:none;
      opacity:0;
      transition: opacity .12s ease;
      background: rgba(255,90,95,.30);
      z-index: 5;
    }
    .flash.on{ opacity:1; }

    .shake{ animation: shake .22s linear; }
    @keyframes shake{
      0%{ transform: translateX(0); }
      25%{ transform: translateX(-6px); }
      50%{ transform: translateX(6px); }
      75%{ transform: translateX(-4px); }
      100%{ transform: translateX(0); }
    }

    .footerNote{ font-size: 12px; color: rgba(255,255,255,.55); text-align:center; margin-top: -6px; }
    .mini{ font-size: 12px; color: rgba(255,255,255,.7); font-weight:800; }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="title">Find the Different Color</div>
      <div class="row" style="gap:8px; justify-content:flex-end;">
        <button id="btnHome" class="btn">Home</button>
        <button id="btnRestart" class="btn primary">Restart</button>
      </div>
    </div>

    <div class="panel">
      <div class="controls">
        <div class="control">
          <label for="gridSize">Grid size</label>
          <select id="gridSize">
            <option value="3">3 × 3</option>
            <option value="4">4 × 4</option>
            <option value="5">5 × 5</option>
            <option value="6" selected>6 × 6</option>
            <option value="7">7 × 7</option>
            <option value="8">8 × 8</option>
          </select>
        </div>

        <div class="control">
          <label for="mode">Mode</label>
          <select id="mode">
            <option value="endless" selected>Endless (time to fail)</option>
            <option value="timed">Timed (reach max level)</option>
          </select>
        </div>

        <div class="control" id="timeControl">
          <label for="timeLimit">Time limit</label>
          <select id="timeLimit">
            <option value="30">30 seconds</option>
            <option value="60" selected>60 seconds</option>
            <option value="90">90 seconds</option>
            <option value="120">120 seconds</option>
          </select>
        </div>

        <div class="control">
          <label for="seed">Seed (0 = random)</label>
          <input id="seed" type="number" inputmode="numeric" min="0" max="2147483647" step="1" value="0" />
        </div>

        <div class="control" style="grid-column: 1 / span 2;">
          <label for="difficulty">Difficulty threshold: <span class="mini" id="difficultyLabel">Hard</span></label>
          <input id="difficulty" type="range" min="0" max="3" step="1" value="1" />
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div class="pill"><span class="muted">Level</span> <strong id="level">1</strong></div>
        <div class="pill"><span class="muted" id="timeLabel">Time</span> <strong id="time">0.0</strong></div>
        <div class="pill"><span class="muted">Delta</span> <strong id="delta">—</strong></div>
        <div class="pill"><span class="muted">Best</span> <strong id="best">—</strong></div>
      </div>
    </div>

    <div class="gridWrap">
      <div class="board" id="board">
        <div class="grid" id="grid"></div>
        <div class="flash" id="flash"></div>

        <div class="overlay" id="overlay">
          <div class="card">
            <h2 id="overlayTitle">Ready?</h2>
            <p id="overlayText">Tap the one square that has a slightly different color. Each level gets harder.</p>

            <div class="scoreBox" id="lastScoreBox" style="display:none;">
              <div class="scoreItem">
                <div class="k">Last level</div>
                <div class="v" id="lastLevel">—</div>
              </div>
              <div class="scoreItem">
                <div class="k" id="lastTimeK">Last time</div>
                <div class="v" id="lastTime">—</div>
              </div>
            </div>

            <div class="row" style="margin-top:12px;">
              <button id="btnStart" class="btn primary">Start</button>
              <button id="btnHow" class="btn">How it works</button>
            </div>
            <p class="footerNote" id="howNote" style="display:none;">
              Endless: wrong tap reveals the correct square for 4 seconds (tap the grid to skip), then score.
              Timed: wrong tap costs 2 seconds (no reveal).
              Seed range: 0 to 2,147,483,647. Use the same seed on multiple devices to get the same game.
            </p>
          </div>
        </div>
      </div>
    </div>

    <div class="footerNote">Tip: add to Home Screen for full-screen play on iPhone.</div>
  </div>

<script>
(() => {
  // ---------- Utilities ----------
  const $ = (id) => document.getElementById(id);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  function rgbToCss(rgb){ return `rgb(${rgb.r},${rgb.g},${rgb.b})`; }
  function luminance(rgb){ return 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b; }
  function formatSeconds(s){ s = Math.max(0, s); return (s < 10) ? s.toFixed(1) : s.toFixed(0); }

  // ---------- Deterministic RNG ----------
  function mulberry32(seed){
    let t = seed >>> 0;
    return function(){
      t += 0x6D2B79F5;
      let x = Math.imul(t ^ (t >>> 15), 1 | t);
      x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }
  function makeRng(seedValue){
    if (!seedValue) return { rand: Math.random, seed: 0 };
    const s = (seedValue >>> 0);
    return { rand: mulberry32(s), seed: s };
  }
  function randInt(rng, a, b){ return Math.floor(rng.rand() * (b - a + 1)) + a; }

  // Difficulty mapping:
  // 0 = Easy (bigger differences, higher floor)
  // 1 = Hard (your current baseline)
  // 2 = Very Hard (smaller differences + lower floor)
  // 3 = Extreme (almost identical at high levels but never identical)
  const DIFF_PRESETS = [
    { name: "Easy",      startBase: 52, floor: 12, decay: 0.90 },
    { name: "Hard",      startBase: 38, floor:  6, decay: 0.92 },
    { name: "Very Hard", startBase: 32, floor:  4, decay: 0.93 },
    { name: "Extreme",   startBase: 26, floor:  2, decay: 0.94 },
  ];

  // Ensure colors are never identical
  const MIN_CHANNEL_DIFF = 1; // extreme allows very tiny changes but non-zero
  function ensureDifferent(base, diff){
    if (base.r === diff.r && base.g === diff.g && base.b === diff.b){
      // force a 1-step move on a channel that can move
      if (diff.r < 255) diff.r += MIN_CHANNEL_DIFF;
      else diff.r -= MIN_CHANNEL_DIFF;
    }
    return diff;
  }

  function currentDifficultyIndex(){
    const v = parseInt(difficultyEl.value || "1", 10);
    return clamp(v, 0, 3);
  }

  function computeDelta(level, size, diffIdx){
    const preset = DIFF_PRESETS[diffIdx];

    // Larger grids: slightly easier start (add a couple points)
    const gridAdj = clamp((8 - size) * 1.2, -2, 6); // small grids a tad harder, big grids a tad easier
    const start = clamp(preset.startBase + gridAdj, preset.floor + 2, 80);

    const d = Math.round(start * Math.pow(preset.decay, level-1));
    // Hard floor prevents becoming identical (and keeps minimum challenge per difficulty)
    return clamp(d, preset.floor, start);
  }

  function makeColors(rng, delta){
    const base = {
      r: randInt(rng, 25, 230),
      g: randInt(rng, 25, 230),
      b: randInt(rng, 25, 230),
    };

    const dir = (rng.rand() < 0.5) ? -1 : 1;

    // Even at extreme, keep *some* change by using delta and small jitter.
    const vr = delta + randInt(rng, -2, 2);
    const vg = delta + randInt(rng, -2, 2);
    const vb = delta + randInt(rng, -2, 2);

    const diff = {
      r: clamp(base.r + dir * vr, 0, 255),
      g: clamp(base.g + dir * vg, 0, 255),
      b: clamp(base.b + dir * vb, 0, 255),
    };

    return { base, diff: ensureDifferent(base, diff) };
  }

  // Best keys include seed + difficulty
  function bestKey(mode, size, timeLimit, seed, diffIdx){
    const seedTag = seed ? `seed:${seed}` : "seed:0";
    return mode === "timed"
      ? `best:v4:timed:${size}:${timeLimit}:${seedTag}:d${diffIdx}`
      : `best:v4:endless:${size}:${seedTag}:d${diffIdx}`;
  }
  function loadBest(mode, size, timeLimit, seed, diffIdx){
    try{
      const raw = localStorage.getItem(bestKey(mode, size, timeLimit, seed, diffIdx));
      return raw ? JSON.parse(raw) : null;
    }catch(e){ return null; }
  }
  function saveBest(mode, size, timeLimit, seed, diffIdx, best){
    try{ localStorage.setItem(bestKey(mode, size, timeLimit, seed, diffIdx), JSON.stringify(best)); }
    catch(e){}
  }

  // ---------- Elements ----------
  const gridEl = $("grid");
  const boardEl = $("board");
  const overlayEl = $("overlay");
  const overlayTitleEl = $("overlayTitle");
  const overlayTextEl = $("overlayText");
  const lastScoreBoxEl = $("lastScoreBox");
  const lastLevelEl = $("lastLevel");
  const lastTimeEl = $("lastTime");
  const lastTimeKEl = $("lastTimeK");
  const howNoteEl = $("howNote");
  const flashEl = $("flash");

  const gridSizeEl = $("gridSize");
  const modeEl = $("mode");
  const timeLimitEl = $("timeLimit");
  const timeControlEl = $("timeControl");
  const seedEl = $("seed");
  const difficultyEl = $("difficulty");
  const difficultyLabelEl = $("difficultyLabel");

  const levelEl = $("level");
  const timeLabelEl = $("timeLabel");
  const timeEl = $("time");
  const deltaEl = $("delta");
  const bestEl = $("best");

  const btnStart = $("btnStart");
  const btnHow = $("btnHow");
  const btnRestart = $("btnRestart");
  const btnHome = $("btnHome");

  // ---------- State ----------
  let state = {
    running: false,
    revealing: false,
    scoreReady: false,
    revealTimer: 0,

    mode: "endless",
    size: 6,
    timeLimit: 60,
    level: 1,

    correctIndex: 0,
    base: {r:0,g:0,b:0},
    diff: {r:0,g:0,b:0},
    delta: 0,

    lastTickTs: 0,
    elapsed: 0,
    remaining: 60,

    raf: 0,

    rng: makeRng(0),
    seed: 0,
    diffIdx: 1,
  };

  // ---------- UI helpers ----------
  function updateTimeControlVisibility(){
    const isTimed = modeEl.value === "timed";
    timeControlEl.style.display = isTimed ? "flex" : "none";
    timeLabelEl.textContent = isTimed ? "Remaining" : "Time";
  }

  function setOverlay(show, title="", text=""){
    overlayEl.style.display = show ? "flex" : "none";
    if (show){
      overlayTitleEl.textContent = title;
      overlayTextEl.textContent = text;
    }
  }

  function showLastScore(level, timeText, timeK){
    lastScoreBoxEl.style.display = "grid";
    lastLevelEl.textContent = String(level);
    lastTimeEl.textContent = timeText;
    lastTimeKEl.textContent = timeK;
  }
  function hideLastScore(){ lastScoreBoxEl.style.display = "none"; }

  function flashBad(){
    flashEl.classList.add("on");
    setTimeout(() => flashEl.classList.remove("on"), 120);
    boardEl.classList.add("shake");
    setTimeout(() => boardEl.classList.remove("shake"), 220);
  }

  function currentSeedValue(){
    const v = parseInt(seedEl.value || "0", 10);
    if (!Number.isFinite(v) || v < 0) return 0;
    return clamp(v, 0, 2147483647);
  }

  function updateDifficultyLabel(){
    const idx = currentDifficultyIndex();
    difficultyLabelEl.textContent = DIFF_PRESETS[idx].name;
  }

  function updateBestLabel(){
    const mode = modeEl.value;
    const size = parseInt(gridSizeEl.value, 10);
    const tl = parseInt(timeLimitEl.value, 10);
    const seed = currentSeedValue();
    const diffIdx = currentDifficultyIndex();
    const best = loadBest(mode, size, tl, seed, diffIdx);
    if (!best){ bestEl.textContent = "—"; return; }
    if (mode === "timed") bestEl.textContent = `L${best.level} / ${best.timeLimit}s`;
    else bestEl.textContent = `L${best.level} / ${best.seconds.toFixed(1)}s`;
  }

  // ---------- Grid ----------
  function buildGrid(){
    const n = state.size;
    const total = n * n;

    gridEl.innerHTML = "";
    gridEl.style.gridTemplateColumns = `repeat(${n}, 1fr)`;
    gridEl.style.gridTemplateRows = `repeat(${n}, 1fr)`;

    const lum = luminance(state.base);
    const line = lum > 150 ? "rgba(0,0,0,.75)" : "rgba(255,255,255,.85)";
    document.documentElement.style.setProperty("--gridLine", line);

    for (let i=0; i<total; i++){
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.i = String(i);
      cell.style.background = (i === state.correctIndex) ? rgbToCss(state.diff) : rgbToCss(state.base);
      gridEl.appendChild(cell);
    }
  }

  function setRevealOutline(on){
    const correct = gridEl.querySelector(`.cell[data-i="${state.correctIndex}"]`);
    if (!correct) return;
    if (on) correct.classList.add("reveal");
    else correct.classList.remove("reveal");
  }

  function nextLevel(){
    state.delta = computeDelta(state.level, state.size, state.diffIdx);
    const { base, diff } = makeColors(state.rng, state.delta);
    state.base = base;
    state.diff = diff;

    const total = state.size * state.size;
    state.correctIndex = randInt(state.rng, 0, total-1);

    levelEl.textContent = String(state.level);
    deltaEl.textContent = String(state.delta);

    buildGrid();
  }

  // ---------- Score ----------
  function showScore(reason){
    const size = state.size;
    const mode = state.mode;
    const tl = state.timeLimit;
    const seed = state.seed;
    const diffIdx = state.diffIdx;

    if (mode === "endless"){
      const seconds = state.elapsed;
      const reachedLevel = state.level;

      const best = loadBest(mode, size, tl, seed, diffIdx);
      const candidate = { level: reachedLevel, seconds: seconds };

      let isNewBest = false;
      if (!best) isNewBest = true;
      else if (candidate.level > best.level) isNewBest = true;
      else if (candidate.level === best.level && candidate.seconds < best.seconds) isNewBest = true;

      if (isNewBest) saveBest(mode, size, tl, seed, diffIdx, candidate);

      updateBestLabel();
      setOverlay(true, reason === "home" ? "Paused" : "Game Over",
        "Endless mode ends on a wrong tap. Try again and beat your best!");
      showLastScore(reachedLevel, `${seconds.toFixed(1)}s`, "Last time");
    } else {
      const reachedLevel = state.level;
      const best = loadBest(mode, size, tl, seed, diffIdx);
      const candidate = { level: reachedLevel, timeLimit: state.timeLimit };

      let isNewBest = false;
      if (!best) isNewBest = true;
      else if (candidate.level > best.level) isNewBest = true;

      if (isNewBest) saveBest(mode, size, tl, seed, diffIdx, candidate);

      updateBestLabel();
      setOverlay(true, reason === "home" ? "Paused" : "Time!",
        "Timed mode: reach the highest level before time runs out.");
      showLastScore(reachedLevel, `${state.timeLimit}s`, "Time limit");
    }
  }

  // ---------- Reveal flow ----------
  const REVEAL_MS = 4000; // requested: 4 seconds
  function beginRevealThenScore(){
    state.running = false;
    cancelAnimationFrame(state.raf);

    state.revealing = true;
    state.scoreReady = false;
    setRevealOutline(true);
    setOverlay(false);

    clearTimeout(state.revealTimer);
    state.revealTimer = setTimeout(() => {
      if (!state.revealing) return;
      state.revealing = false;
      setRevealOutline(false);
      showScore("wrong");
    }, REVEAL_MS);

    // Prevent the *same* loss tap from instantly skipping the reveal.
    setTimeout(() => { state.scoreReady = true; }, 150);
  }

  function endRun(reason){
    if (reason === "wrong" && state.mode === "endless"){
      beginRevealThenScore();
      return;
    }

    state.running = false;
    state.revealing = false;
    state.scoreReady = true;
    clearTimeout(state.revealTimer);
    cancelAnimationFrame(state.raf);
    setRevealOutline(false);
    showScore(reason);
  }

  // ---------- Tick ----------
  function tick(){
    if (!state.running) return;
    const now = performance.now();
    const dt = (now - state.lastTickTs) / 1000;
    state.lastTickTs = now;

    if (state.mode === "timed"){
      state.remaining -= dt;
      if (state.remaining <= 0){
        state.remaining = 0;
        timeEl.textContent = formatSeconds(state.remaining);
        endRun("timeout");
        return;
      }
      timeEl.textContent = formatSeconds(state.remaining);
    } else {
      state.elapsed += dt;
      timeEl.textContent = formatSeconds(state.elapsed);
    }
    state.raf = requestAnimationFrame(tick);
  }

  // ---------- Start/Reset ----------
  function startRun(){
    state.mode = modeEl.value;
    state.size = parseInt(gridSizeEl.value, 10);
    state.timeLimit = parseInt(timeLimitEl.value, 10);

    state.seed = currentSeedValue();
    state.rng = makeRng(state.seed);
    state.diffIdx = currentDifficultyIndex();

    state.running = true;
    state.revealing = false;
    state.scoreReady = false;
    clearTimeout(state.revealTimer);

    state.level = 1;
    state.elapsed = 0;
    state.lastTickTs = performance.now();

    if (state.mode === "timed"){
      state.remaining = state.timeLimit;
      timeLabelEl.textContent = "Remaining";
      timeEl.textContent = formatSeconds(state.remaining);
    } else {
      timeLabelEl.textContent = "Time";
      timeEl.textContent = formatSeconds(0);
    }

    hideLastScore();
    setOverlay(false);
    nextLevel();
    tick();
    updateBestLabel();
  }

  function resetToHome(){
    state.running = false;
    state.revealing = false;
    state.scoreReady = false;
    clearTimeout(state.revealTimer);
    cancelAnimationFrame(state.raf);
    setRevealOutline(false);

    setOverlay(true, "Ready?", "Tap the one square that has a slightly different color. Each level gets harder.");
    hideLastScore();

    state.size = parseInt(gridSizeEl.value, 10);
    state.level = 1;
    state.seed = currentSeedValue();
    state.rng = makeRng(state.seed);
    state.diffIdx = currentDifficultyIndex();

    state.delta = computeDelta(1, state.size, state.diffIdx);
    const c = makeColors(state.rng, state.delta);
    state.base = c.base; state.diff = c.diff;
    state.correctIndex = randInt(state.rng, 0, state.size*state.size - 1);

    deltaEl.textContent = "—";
    levelEl.textContent = "1";
    timeEl.textContent = "0.0";
    buildGrid();
    updateBestLabel();
  }

  // ---------- Input ----------
  function onTapCell(index){
    if (state.revealing){
      if (!state.scoreReady) return;
      state.revealing = false;
      clearTimeout(state.revealTimer);
      setRevealOutline(false);
      showScore("wrong");
      return;
    }

    if (!state.running) return;

    if (index === state.correctIndex){
      state.level += 1;
      nextLevel();
      return;
    }

    flashBad();
    if (state.mode === "endless"){
      endRun("wrong");
    } else {
      state.remaining = Math.max(0, state.remaining - 2);
      timeEl.textContent = formatSeconds(state.remaining);
      if (state.remaining <= 0) endRun("timeout");
    }
  }

  gridEl.addEventListener("pointerdown", (e) => {
    const t = e.target;
    if (!(t instanceof HTMLElement)) return;
    if (!t.classList.contains("cell")) return;
    e.preventDefault();
    const idx = parseInt(t.dataset.i, 10);
    onTapCell(idx);
  }, { passive:false });

  boardEl.addEventListener("pointerdown", (e) => {
    if (!state.revealing) return;
    if (!state.scoreReady) return;
    e.preventDefault();
    state.revealing = false;
    clearTimeout(state.revealTimer);
    setRevealOutline(false);
    showScore("wrong");
  }, { passive:false });

  // Prevent iOS double-tap zoom
  let lastTouchEnd = 0;
  document.addEventListener("touchend", (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = now;
  }, { passive:false });

  // ---------- Controls ----------
  modeEl.addEventListener("change", () => { updateTimeControlVisibility(); updateBestLabel(); });
  gridSizeEl.addEventListener("change", () => { updateBestLabel(); resetToHome(); });
  timeLimitEl.addEventListener("change", () => updateBestLabel());
  seedEl.addEventListener("change", () => { seedEl.value = String(currentSeedValue()); updateBestLabel(); resetToHome(); });
  seedEl.addEventListener("blur", () => { seedEl.value = String(currentSeedValue()); });

  difficultyEl.addEventListener("input", () => {
    updateDifficultyLabel();
    updateBestLabel();
  });
  difficultyEl.addEventListener("change", () => {
    updateDifficultyLabel();
    updateBestLabel();
    resetToHome();
  });

  btnStart.addEventListener("click", startRun);
  btnRestart.addEventListener("click", resetToHome);
  btnHome.addEventListener("click", resetToHome);

  btnHow.addEventListener("click", () => {
    howNoteEl.style.display = (howNoteEl.style.display === "none") ? "block" : "none";
  });

  // Init
  updateTimeControlVisibility();
  updateDifficultyLabel();
  resetToHome();
})();
</script>
</body>
</html>